<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>linux实用指令</title>
    <link href="/2021/12/15/linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/12/15/linux%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">find . -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">print</span> | wc -l<br>find /var/<span class="hljs-built_in">log</span>/ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">print</span> | wc -l<br><br>find . -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*far*&quot;</span> -<span class="hljs-built_in">print</span> | wc -l<br></code></pre></td></tr></table></figure><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><strong>启动一个 screen 会话</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">screen -S <span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><p><strong>从 screen 会话中分离</strong></p><p>要从当前的 screen 会话中分离，你可以按下Ctrl+d。，或者在命令行中使用 exit 命令。所有的 screen 会话仍将是活跃的，你之后可以随时重新连接。</p><p><strong>重新连接到 screen 会话</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">screen -r <span class="hljs-built_in">name</span><br></code></pre></td></tr></table></figure><p>列出所有会话</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">screen -ls</span><br></code></pre></td></tr></table></figure><p>man手册</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">man screen</span><br></code></pre></td></tr></table></figure><p>踢出attached的会话，自己插进去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">screen -D -r name<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S yourname           <span class="hljs-comment"># 新建一个叫yourname的session</span><br>screen -ls                   <span class="hljs-comment"># 列出当前所有的session</span><br>screen -r yourname           <span class="hljs-comment"># 回到yourname这个session</span><br>screen -d yourname           <span class="hljs-comment"># 远程detach某个session    # detach快捷键 ctrl a + d</span><br>screen -d -r yourname        <span class="hljs-comment"># 结束当前session并回到yourname这个session</span><br>screen -S yourname -X quit   <span class="hljs-comment"># 删除叫yourname的session</span><br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vim">从linux本机文件上传到另一台linux:<br>scp 要传的文件 root@目标ip:路径<br>scp –r 要传的目录 root@目标ip:路径<br><br>从linux下载文件到linux本机：<br>scp (-r) 用户名@目标IP地址：文件路径 本地位置<br><br><span class="hljs-keyword">ps</span> aux:<br><span class="hljs-number">1</span>）<span class="hljs-keyword">ps</span> <span class="hljs-keyword">a</span> 显示现行终端机下的所有程序，包括其他用户的程序。<br><span class="hljs-number">2</span>）<span class="hljs-keyword">ps</span> -A 显示所有程序。<br><span class="hljs-number">3</span>）<span class="hljs-keyword">ps</span> <span class="hljs-keyword">c</span> 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。<br><span class="hljs-number">4</span>）<span class="hljs-keyword">ps</span> -<span class="hljs-keyword">e</span> 此参数的效果和指定<span class="hljs-string">&quot;A&quot;</span>参数相同。<br><span class="hljs-number">5</span>）<span class="hljs-keyword">ps</span> <span class="hljs-keyword">e</span> 列出程序时，显示每个程序所使用的环境变量。<br><span class="hljs-number">6</span>）<span class="hljs-keyword">ps</span> <span class="hljs-keyword">f</span> 用ASCII字符显示树状结构，表达程序间的相互关系。<br><span class="hljs-number">7</span>）<span class="hljs-keyword">ps</span> -H 显示树状结构，表示程序间的相互关系。<br><span class="hljs-number">8</span>）<span class="hljs-keyword">ps</span> -<span class="hljs-keyword">N</span> 显示所有的程序，除了执行<span class="hljs-keyword">ps</span>指令终端机下的程序之外。<br><span class="hljs-number">9</span>）<span class="hljs-keyword">ps</span> s 采用程序信号的格式显示程序状况。<br><span class="hljs-number">10</span>）<span class="hljs-keyword">ps</span> S 列出程序时，包括已中断的子程序资料。<br><span class="hljs-number">11</span>）<span class="hljs-keyword">ps</span> -t &lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。<br><span class="hljs-number">12</span>）<span class="hljs-keyword">ps</span> <span class="hljs-keyword">u</span> 　 以用户为主的格式来显示程序状况。<br><span class="hljs-number">13</span>）<span class="hljs-keyword">ps</span> <span class="hljs-keyword">x</span> 　 显示所有程序，不以终端机来区分。<br><span class="hljs-number">14</span>）<span class="hljs-keyword">ps</span> -<span class="hljs-keyword">l</span> 較長,較詳細的顯示該PID的信息<br><br>awk是把文本一行一行的处理<br>awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span><br>含义是把管道中的数据每一行按空格分隔提取，然后把第二项输出<br><br><span class="hljs-keyword">grep</span>:http<span class="hljs-variable">s:</span>//www.runoob.<span class="hljs-keyword">com</span>/linux/linux-comm-<span class="hljs-keyword">grep</span>.html?spm=a2c6h.<span class="hljs-number">12873639.0</span>.<span class="hljs-number">0.69</span>bf188aOkfYQ3<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/duanxz/p/4511198.html">pkill</a></p><ul><li>cache line size<br>cat/sys/devices/system/cpu/cpu1/cache/index0/coherency_line_size </li></ul><p>汇编</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -S -fverbose-<span class="hljs-keyword">asm</span> test.<span class="hljs-keyword">c</span> //输出汇编文件test.s，-fverbose-<span class="hljs-keyword">asm</span>可以将文件中的变量以注释的方式写出来<br></code></pre></td></tr></table></figure><p>没有源文件就要反汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>查找</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">find</span> ./ -name memcpy.S<br><span class="hljs-keyword">ls</span> -lR |<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;memcpy&quot;</span><br></code></pre></td></tr></table></figure><p>df</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">sudo du -<span class="hljs-keyword">sh</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span><span class="hljs-comment">/* 2</span><br></code></pre></td></tr></table></figure><h3 id="绑核"><a href="#绑核" class="headerlink" title="绑核"></a>绑核</h3><p>物理核，逻辑核</p><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>CPU(Central Processing Unit): 中央处理单元，CPU不等于物理核，更不等于逻辑核。<br>物理核(physical core/processor): 可以看的到的，真实的cpu核，有独立的电路元件以及L1,L2缓存，可以独立地执行指令。<br>逻辑核(logical core/processor，LCPU): 在同一个物理核内，逻辑层面的核。（比喻，像动画片一样，我们看到的“动画”，其实是一帧一帧静态的画面，24帧/s连起来就骗过了人类的眼睛，看起来像动起来一样。逻辑核也一样，物理核通过高速运算，让应用程序以为有两个cpu在运算）。<br>超线程(Hyper-threading， HT)：超线程可以在一个逻辑核等待指令执行的间隔(等待从cache或内存中获取下一条指令)，把时间片分配到另一个逻辑核。高速在这两个逻辑核之间切换，让应用程序感知不到这个间隔，误认为自己是独占了一个核。<br>关系: 一个CPU可以有多个物理核。如果开启了超线程，一个物理核可以分成n个逻辑核，n为超线程的数量。</p><h4 id="单核CPU和超线程"><a href="#单核CPU和超线程" class="headerlink" title="单核CPU和超线程"></a>单核CPU和超线程</h4><p>在多核，虚拟或逻辑cpu之类的概念之前，在奔腾处理器时代，大多数计算机安装在他们的主板上的单个芯片相当大，我们称之为微处理器、处理器或简称CPU。只有少数企业计算机或需要更多处理能力的大型服务器可以在同一块板上安装2个或更多这些芯片：它们是多处理器系统。<br>这些芯片通过连接器或插槽与其他主板元件通信。<br>计算很简单：这么多连接器或插槽有一主板，一台电脑最多只能有这么多cpu。如果你想要更多的处理能力，你只需要寻找一个拥有更多处理器的板，或者等待它们的发展来提供更高的性能。</p><p>但随后英特尔意识到多处理器系统的不同处理器之间的通信效率非常低，因为它们必须通过系统总线完成，而系统总线通常以低得多的速度工作。这通常导致出现瓶颈，使得无法充分利用每个CPU提供的计算能力。</p><p>为了改善这种情况，开发了超线程技术(HT)。HT是关于在相同的芯片中复制一些CPU内部组件，例如寄存器或一级缓存，以便在两个不同的执行线程之间共享信息，而不必通过具有相应瓶颈和速度损失问题的系统总线。这也允许如果一个进程必须等待中断，另一个进程可以继续使用CPU而不停止它。<br>这样就有可能加快数个计算过程，并开始提供比传统处理器性能更好的处理器。操作系统被欺骗了，因为它被提供了两个虚拟或逻辑cpu (LCPU)，而不是单个cpu，因为它被允许“同时”执行两个进程。但是值得注意的是，不可能产生传统处理器两倍的处理能力，也不可能提供完全的并行处理能力。<br>因此，从Linux或其他操作系统的角度来看，一个只有一个核心处理器但HT的机器就像有两个cpu一样出现在我们眼前。但是这是在同一个物理cpu中运行的两个逻辑cpu。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">lscpu</span><br><span class="hljs-attr">Architecture:</span>          <span class="hljs-string">x86_64</span>  <span class="hljs-comment">#架构 </span><br><span class="hljs-string">CPU</span> <span class="hljs-string">op-mode(s):</span>        <span class="hljs-number">32</span><span class="hljs-string">-bit,</span> <span class="hljs-number">64</span><span class="hljs-string">-bit</span> <span class="hljs-comment">#运行方式</span><br><span class="hljs-attr">Byte Order:</span>            <span class="hljs-string">Little</span> <span class="hljs-string">Endian</span>  <span class="hljs-comment">#字节顺序</span><br><span class="hljs-string">CPU(s):</span>                <span class="hljs-number">2</span>  <span class="hljs-comment">#逻辑cpu颗数 </span><br><span class="hljs-string">On-line</span> <span class="hljs-string">CPU(s)</span> <span class="hljs-attr">list:</span>   <span class="hljs-number">0</span><span class="hljs-string">,1</span>  <span class="hljs-comment">#在线CPU</span><br><span class="hljs-string">Thread(s)</span> <span class="hljs-attr">per core:</span>    <span class="hljs-number">2</span>  <span class="hljs-comment">#每个核心线程</span><br><span class="hljs-string">Core(s)</span> <span class="hljs-attr">per socket:</span>    <span class="hljs-number">1</span>  <span class="hljs-comment">#每个cpu插槽核数/每颗物理cpu核数 </span><br><span class="hljs-string">Socket(s):</span>             <span class="hljs-number">1</span>  <span class="hljs-comment">#cpu插槽数 </span><br><span class="hljs-string">NUMA</span> <span class="hljs-string">node(s):</span>          <span class="hljs-number">1</span>  <span class="hljs-comment">#非统一内存访问节点</span><br><span class="hljs-attr">Vendor ID:</span>             <span class="hljs-string">GenuineIntel</span>  <span class="hljs-comment">#cpu厂商ID </span><br><span class="hljs-attr">CPU family:</span>            <span class="hljs-number">6</span>   <span class="hljs-comment">#cpu系列 </span><br><span class="hljs-attr">Model:</span>                 <span class="hljs-number">63</span>  <span class="hljs-comment">#型号编号</span><br><span class="hljs-attr">Model name:</span>            <span class="hljs-string">Intel(R)</span> <span class="hljs-string">Xeon(R)</span> <span class="hljs-string">CPU</span> <span class="hljs-string">E5-2680</span> <span class="hljs-string">v3</span> <span class="hljs-string">@</span> <span class="hljs-number">2.</span><span class="hljs-string">50GHz</span> <span class="hljs-comment">#型号名称</span><br><span class="hljs-attr">Stepping:</span>              <span class="hljs-number">2</span>  <span class="hljs-comment">#步进</span><br><span class="hljs-attr">CPU MHz:</span>               <span class="hljs-number">2494.222</span>  <span class="hljs-comment">#cpu主频 </span><br><span class="hljs-attr">BogoMIPS:</span>              <span class="hljs-number">4988.44</span><br><span class="hljs-attr">Hypervisor vendor:</span>     <span class="hljs-string">KVM</span>  <span class="hljs-comment">#虚拟化架构</span><br><span class="hljs-attr">Virtualization type:</span>   <span class="hljs-string">full</span>  <span class="hljs-comment">#cpu支持的虚拟化技术 </span><br><span class="hljs-attr">L1d cache:</span>             <span class="hljs-string">32K</span>  <span class="hljs-comment">#一级缓存(具体为L1数据缓存） </span><br><span class="hljs-attr">L1i cache:</span>             <span class="hljs-string">32K</span>  <span class="hljs-comment">#一级缓存（具体为L1指令缓存） </span><br><span class="hljs-attr">L2 cache:</span>              <span class="hljs-string">256K</span> <span class="hljs-comment">#二级缓存</span><br><span class="hljs-attr">L3 cache:</span>              <span class="hljs-string">30720K</span> <span class="hljs-comment">#三级缓存</span><br><span class="hljs-string">NUMA</span> <span class="hljs-string">node0</span> <span class="hljs-string">CPU(s):</span>     <span class="hljs-number">0</span><span class="hljs-string">,1</span><br></code></pre></td></tr></table></figure><h4 id="绑定方法"><a href="#绑定方法" class="headerlink" title="绑定方法"></a>绑定方法</h4><h5 id="使用taskset指令"><a href="#使用taskset指令" class="headerlink" title="使用taskset指令"></a>使用taskset指令</h5><p>获取进程pid<br>-&gt; % ps<br>查看进程当前运行在哪个cpu上<br>-&gt; % taskset -p 2726<br>显示的十进制数字3转换为2进制为最低两个是1，每个1对应一个cpu，所以进程运行在2个cpu上。</p><p>指定进程运行在cpu1上<br>-&gt; % taskset -pc 1 2726<br>注意，cpu的标号是从0开始的，所以cpu1表示第二个cpu（第一个cpu的标号是0）。</p><p>至此，就把应用程序绑定到了cpu1上运行，查看如下：<br>启动程序时绑定cpu<br>#启动时绑定到第二个cpu<br>-&gt; % taskset -c 1 ./dgram_servr&amp;<br>#查看确认绑定情况<br>-&gt; % taskset -p 3011</p><p>或者在程序中指定，方法如<a href="https://blog.csdn.net/guotianqing/article/details/80958281">参考</a></p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>shell下直接输入gdb即可进入调试界面，再输入help显示命令种类<br>想要调试就得文件中带有调试信息。gcc编译的时候带着-g选项。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gdb <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.out</span><span class="hljs-comment">//如果带有调试信息就可以开始了</span><br><br><span class="hljs-comment">//或者先进入gdb再打开文件</span><br>gdb<br>file <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.out</span><br>r xxxx<span class="hljs-comment">//如果需要传参数就在r（run命令的缩写）后面加上即可</span><br></code></pre></td></tr></table></figure><p>设置断点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">break</span> [行号]<span class="hljs-regexp">//</span><span class="hljs-keyword">break</span>缩写b 行号可以用 文件名：行号 的方式指定<br></code></pre></td></tr></table></figure><p>list查看源码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">list breakpoints <span class="hljs-regexp">//</span>显示断点附近的<br>list  <span class="hljs-regexp">//</span>显示当前的运行附近的代码<br>list 函数名 <span class="hljs-regexp">//</span>显示函数代码<br>list <span class="hljs-number">6</span>,<span class="hljs-number">10</span><span class="hljs-regexp">//</span>显示<span class="hljs-number">6</span>到<span class="hljs-number">10</span>行的代码<br></code></pre></td></tr></table></figure><p>调试</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">1</span>、<span class="hljs-keyword">next</span>命令（可简写为n）用于在程序断住后，继续执行下一条语句。<br><span class="hljs-number">2</span>、<span class="hljs-keyword">step</span>命令（可简写为s），它可以单步跟踪到函数内部。<br><span class="hljs-number">3</span>、<span class="hljs-keyword">continue</span>命令（可简写为c）或者fg，它会继续执行程序，直到再次遇到断点处。<br></code></pre></td></tr></table></figure><p>print 查看变量内容 </p><p>多个函数或者多个文件会有同一个变量名，这个时候可以在前面加上文件名或者函数名来区分：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> <span class="hljs-string">&#x27;testfile.c&#x27;</span>::<span class="hljs-selector-tag">i</span><br><span class="hljs-selector-tag">p</span> <span class="hljs-string">&#x27;sum&#x27;</span>::i<br></code></pre></td></tr></table></figure><p>打印指针指向的内容就加<em>，想要打印多个值就@后加打印的行数，例如</em>dst@3</p><ul><li>set设置变量值继续执行<br>这个好，断点时刻设置当前变量值继续执行。<br>语法：</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-number">1.</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">variable</span> <span class="hljs-comment">key = value</span><br>2. <span class="hljs-keyword">set</span> <span class="hljs-comment">var key = value</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">(gdb) <span class="hljs-keyword">set</span> <span class="hljs-keyword">variable</span> <span class="hljs-comment">array[1] = 12</span><br></code></pre></td></tr></table></figure><p>用之前的print也可以<br>语法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span>  <span class="hljs-attribute">key</span>=value<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">(gdb) print array[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>设置观察点<br>watch num 当num变化的时候自动停下来。显示改变前后值。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>想要使用特定版本的汇编版本的函数文件替换glibc中的发现直接gcc添加即可，没啥特别注意的。<br>这里码一篇<a href="https://segmentfault.com/a/1190000019782782">参考文章</a>以备不时之需</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc bench<span class="hljs-selector-class">.c</span> memcpy<span class="hljs-selector-class">.S</span><br><br><span class="hljs-comment">//或者将汇编文件编译生成二进制文件memcpy.o,然后再一起</span><br>gcc -c memcpy<span class="hljs-selector-class">.S</span> <br>gcc bench<span class="hljs-selector-class">.c</span> memcpy<span class="hljs-selector-class">.o</span><br><br><span class="hljs-comment">//或者再生成库函数文件</span><br>ar -rcs memcpy<span class="hljs-selector-class">.a</span> memcpy<span class="hljs-selector-class">.o</span><br>gcc bench<span class="hljs-selector-class">.c</span> memcpy.a<br></code></pre></td></tr></table></figure><p>ldd可以查看动态链接库</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">ldd a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>查看是否替换成功,可以反汇编，如果替换成功那么应该有memcpy模块，替换失败就使用默认的不会出现。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>bash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载：和我一起写makefile</title>
    <link href="/2021/12/15/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99makefile/"/>
    <url>/2021/12/15/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99makefile/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>转载链接：<a href="https://seisman.github.io/how-to-write-makefile/overview.html#id2">和我一起写makefile</a></p>          </div><h1 id="makefile介绍"><a href="#makefile介绍" class="headerlink" title="makefile介绍"></a>makefile介绍</h1><h2 id="makefile的规则"><a href="#makefile的规则" class="headerlink" title="makefile的规则"></a>makefile的规则</h2><p>在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">target <span class="hljs-string">...</span> : prerequisites <span class="hljs-string">...</span><br>    <span class="hljs-keyword">command</span><br>    <span class="hljs-string">...</span><br>    <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><ul><li><p>target</p><p>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p></li><li><p>prerequisites</p><p>生成该target所依赖的文件和/或target</p></li><li><p>command</p><p>该target要执行的命令（任意的shell命令）</p></li></ul><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">prerequisites中如果有一个以上的文件比<span class="hljs-keyword">target</span>文件要新的话，<span class="hljs-keyword">command</span>所定义的命令就会被执行。<br></code></pre></td></tr></table></figure><p>这就是makefile的规则，也就是makefile中最核心的内容。</p><h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>正如前面所说，如果一个工程有3个头文件和8个c文件，为了完成前面所述的那三个规则，我们的makefile 应该是下面的这个样子的。(下面的edit也是文件名，不是啥命令)</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">edit</span> : main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>        <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">o</span> <span class="hljs-keyword">edit</span> main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>        <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br><br>main.<span class="hljs-keyword">o</span> : main.<span class="hljs-keyword">c</span> defs.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> main.<span class="hljs-keyword">c</span><br>kbd.<span class="hljs-keyword">o</span> : kbd.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">command</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> kbd.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">command</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">command</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">display</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">c</span><br><span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> : <span class="hljs-built_in">search</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">files</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h <span class="hljs-keyword">command</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">c</span><br>utils.<span class="hljs-keyword">o</span> : utils.<span class="hljs-keyword">c</span> defs.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> utils.<span class="hljs-keyword">c</span><br>clean :<br>    rm <span class="hljs-keyword">edit</span> main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>        <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br></code></pre></td></tr></table></figure><p>反斜杠（ <code>\</code> ）是换行符的意思。这样比较便于makefile的阅读。我们可以把这个内容保存在名字为“makefile”或“Makefile”的文件中，然后在该目录下直接输入命令 <code>make</code> 就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 <code>make clean</code> 就可以了。     <strong>make clean</strong></p><p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ <code>*.o</code> ），依赖文件（prerequisites）就是冒号后面的那些 <code>.c</code> 文件和 <code>.h</code> 文件。每一个 <code>.o</code> 文件都有一组依赖文件，而这些 <code>.o</code> 文件又是执行文件 <code>edit</code> 的依赖文件。依赖关系的实质就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 <code>Tab</code> 键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p><p>这里要说明一点的是， <strong><code>clean</code> 不是一个文件</strong>，它只不过是一个动作名字，有点像c语言中的label一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><h2 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h2><p>在默认的方式下，也就是我们只输入 <code>make</code> 命令。那么，</p><ol><li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li><li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li><li>如果edit文件不存在，或是edit所依赖的后面的 <code>.o</code> 文件的文件修改时间要比 <code>edit</code> 这个文件新，那么，他就会执行后面所定义的命令来生成 <code>edit</code> 这个文件。</li><li>如果 <code>edit</code> 所依赖的 <code>.o</code> 文件也不存在，那么make会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件。（这有点像一个堆栈的过程）</li><li>当然，你的C文件和H文件是存在的啦，于是make会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成make的终极任务，也就是执行文件 <code>edit</code> 了。</li></ol><h2 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h2><p>在上面的例子中，先让我们看看edit的规则：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">edit</span> : main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>        <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">o</span> <span class="hljs-keyword">edit</span> main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>        <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br></code></pre></td></tr></table></figure><p>我们可以看到 <code>.o</code> 文件的字符串被重复了两次，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p><p>我们在makefile一开始就这样定义：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">objects = main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>     <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br></code></pre></td></tr></table></figure><p>于是，我们就可以很方便地在我们的makefile中以 <code>$(objects)</code> 的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vim">objects = main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>    <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br><br><span class="hljs-keyword">edit</span> : $(objects)<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">o</span> <span class="hljs-keyword">edit</span> $(objects)<br>main.<span class="hljs-keyword">o</span> : main.<span class="hljs-keyword">c</span> defs.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> main.<span class="hljs-keyword">c</span><br>kbd.<span class="hljs-keyword">o</span> : kbd.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">command</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> kbd.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">command</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">command</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">display</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">c</span><br><span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> : <span class="hljs-built_in">search</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">c</span><br><span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> : <span class="hljs-keyword">files</span>.<span class="hljs-keyword">c</span> defs.h <span class="hljs-keyword">buffer</span>.h <span class="hljs-keyword">command</span>.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">c</span><br>utils.<span class="hljs-keyword">o</span> : utils.<span class="hljs-keyword">c</span> defs.h<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> utils.<span class="hljs-keyword">c</span><br>clean :<br>    rm <span class="hljs-keyword">edit</span> $(objects)<br></code></pre></td></tr></table></figure><p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。</p><h2 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p><p><strong>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中</strong>，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的新makefile又出炉了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">objects = main.<span class="hljs-keyword">o</span> kbd.<span class="hljs-keyword">o</span> <span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> \<br>    <span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> <span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> <span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> utils.<span class="hljs-keyword">o</span><br><br><span class="hljs-keyword">edit</span> : $(objects)<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">o</span> <span class="hljs-keyword">edit</span> $(objects)<br><br>main.<span class="hljs-keyword">o</span> : defs.h<br>kbd.<span class="hljs-keyword">o</span> : defs.h <span class="hljs-keyword">command</span>.h<br><span class="hljs-keyword">command</span>.<span class="hljs-keyword">o</span> : defs.h <span class="hljs-keyword">command</span>.h<br><span class="hljs-keyword">display</span>.<span class="hljs-keyword">o</span> : defs.h <span class="hljs-keyword">buffer</span>.h<br><span class="hljs-keyword">insert</span>.<span class="hljs-keyword">o</span> : defs.h <span class="hljs-keyword">buffer</span>.h<br><span class="hljs-built_in">search</span>.<span class="hljs-keyword">o</span> : defs.h <span class="hljs-keyword">buffer</span>.h<br><span class="hljs-keyword">files</span>.<span class="hljs-keyword">o</span> : defs.h <span class="hljs-keyword">buffer</span>.h <span class="hljs-keyword">command</span>.h<br>utils.<span class="hljs-keyword">o</span> : defs.h<br><br>.PHONY : clean<br>clean :<br>    rm <span class="hljs-keyword">edit</span> $(objects)<br></code></pre></td></tr></table></figure><p>这种方法，也就是make的“隐晦规则”。上面文件内容中， <code>.PHONY</code> 表示 <code>clean</code> 是个伪目标文件。</p><h2 id="Makefile里有什么？"><a href="#Makefile里有什么？" class="headerlink" title="Makefile里有什么？"></a>Makefile里有什么？</h2><p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p><ol><li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li><li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。</li><li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li><li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li><li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 <code>#</code> 字符，这个就像C/C++中的 <code>//</code> 一样。如果你要在你的Makefile中使用 <code>#</code> 字符，可以用反斜杠进行转义，如： <code>\#</code> 。</li></ol><p>最后，还值得一提的是，<strong>在Makefile中的命令，必须要以 <code>Tab</code> 键开始。</strong></p><h2 id="Makefile的文件名"><a href="#Makefile的文件名" class="headerlink" title="Makefile的文件名"></a>Makefile的文件名</h2><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p><p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的 <code>-f</code> 和 <code>--file</code> 参数，如： <code>make -f Make.Linux</code> 或 <code>make --file Make.AIX</code> 。</p><h2 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h2><p>在Makefile使用 <code>include</code> 关键字可以把别的Makefile包含进来，这很像C语言的 <code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。 <code>include</code> 的语法是：</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span> &lt;filename&gt;</span><br></code></pre></td></tr></table></figure><p><code>filename</code> 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。</p><p>在 <code>include</code> 前面可以有一些空字符，但是绝不能是 <code>Tab</code> 键开始。 <code>include</code> 和 <code>&lt;filename&gt;</code> 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： <code>a.mk</code> 、 <code>b.mk</code> 、 <code>c.mk</code> ，还有一个文件叫 <code>foo.make</code> ，以及一个变量 <code>$(bar)</code> ，其包含了 <code>e.mk</code> 和 <code>f.mk</code> ，那么，下面的语句：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">include</span> foo.make *.mk <span class="hljs-constructor">$(<span class="hljs-params">bar</span>)</span><br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">include foo<span class="hljs-selector-class">.make</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.mk</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.mk</span> c<span class="hljs-selector-class">.mk</span> e<span class="hljs-selector-class">.mk</span> f.mk<br></code></pre></td></tr></table></figure><p>make命令开始时，会找寻 <code>include</code> 所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><ol><li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>如果目录 <code>&lt;prefix&gt;/include</code> （一般是： <code>/usr/local/bin</code> 或 <code>/usr/include</code> ）存在的话，make也会去找。</li></ol><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby"><span class="hljs-keyword">include</span> &lt;filename&gt;</span><br></code></pre></td></tr></table></figure><p>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p><h2 id="环境变量MAKEFILES"><a href="#环境变量MAKEFILES" class="headerlink" title="环境变量MAKEFILES"></a>环境变量MAKEFILES</h2><p>如果你的当前环境中定义了环境变量 <code>MAKEFILES</code> ，那么，make会把这个变量中的值做一个类似于 <code>include</code> 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 <code>include</code> 不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p><p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p><h2 id="make的工作方式"><a href="#make的工作方式" class="headerlink" title="make的工作方式"></a>make的工作方式</h2><p>GNU的make工作时的执行步骤如下：（想来其它的make也是类似）</p><ol><li>读入所有的Makefile。</li><li>读入被include的其它Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol><p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p><p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p><p><a href="https://seisman.github.io/how-to-write-makefile/rules.html">Next </a><a href="https://seisman.github.io/how-to-write-makefile/overview.html"> Previous</a></p><h1 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p><p>在Makefile中，规则的顺序是很重要的，因为，<strong>Makefile中只应该有一个最终目标</strong>，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p><p>好了，还是让我们来看一看如何书写规则。</p><h2 id="规则举例"><a href="#规则举例" class="headerlink" title="规则举例"></a>规则举例</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">foo.o: foo.<span class="hljs-keyword">c</span> defs.h       # foo模块<br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> -g foo.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>看到这个例子，各位应该不是很陌生了，前面也已说过， <code>foo.o</code> 是我们的目标， <code>foo.c</code> 和 <code>defs.h</code> 是目标所依赖的源文件，而只有一个命令 <code>cc -c -g foo.c</code> （以Tab键开头）。这个规则告诉我们两件事：</p><ol><li>文件的依赖关系， <code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>defs.h</code> 的文件，如果 <code>foo.c</code> 和 <code>defs.h</code> 的文件日期要比 <code>foo.o</code> 文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖关系发生。</li><li>生成或更新 <code>foo.o</code> 文件，就是那个cc命令。它说明了如何生成 <code>foo.o</code> 这个文件。（当然，foo.c文件include了defs.h文件）</li></ol><h2 id="规则的语法"><a href="#规则的语法" class="headerlink" title="规则的语法"></a>规则的语法</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">targets : prerequisites<br>    <span class="hljs-keyword">command</span><br>    <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>或是这样：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">targets : prerequisites ; <span class="hljs-keyword">command</span><br>    <span class="hljs-keyword">command</span><br>    <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p><p>command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 <code>Tab</code> 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p><p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。</p><p>如果命令太长，你可以使用反斜杠（ <code>\</code> ）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。</p><p>一般来说，make会以UNIX的标准Shell，也就是 <code>/bin/sh</code> 来执行命令。</p><h2 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h2><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> 。这是和Unix的B-Shell是相同的。</p><p>波浪号（ <code>~</code> ）字符在文件名中也有比较特殊的用途。如果是 <code>~/test</code> ，这就表示当前用户的 <code>$HOME</code> 目录下的test目录。而 <code>~hchen/test</code> 则表示用户hchen的宿主目录下的test 目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是 MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。</p><p>通配符代替了你一系列的文件，如 <code>*.c</code> 表示所有后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如： <code>*</code> ，那么可以用转义字符 <code>\</code> ，如 <code>\*</code> 来表示真实的 <code>*</code> 字符，而不是任意长度的字符串。</p><p>好吧，还是先来看几个例子吧：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">clean:<br>    <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> *.o<br></code></pre></td></tr></table></figure><p>其实在这个clean:后面可以加上你想做的一些事情，如果你想看到在编译完后看看main.c的源代码，你可以在加上cat这个命令，例子如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">clean:<br>    <span class="hljs-built_in">cat</span> main.c<br>    <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> *.o<br></code></pre></td></tr></table></figure><p>其结果你试一下就知道的。 上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-built_in">print</span>: *.c<br>    lpr -p $?<br>    <span class="hljs-keyword">touch</span> <span class="hljs-built_in">print</span><br></code></pre></td></tr></table></figure><p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的 <code>.c</code> 文件。其中的 <code>$?</code> 是一个自动化变量，我会在后面给你讲述。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">objects</span> = *.o<br></code></pre></td></tr></table></figure><p>上面这个例子，表示了通配符同样可以用在变量中。并不是说 <code>*.o</code> 会展开，不！objects的值就是 <code>*.o</code> 。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有 <code>.o</code> 的文件名的集合，那么，你可以这样：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.o)</span><br></code></pre></td></tr></table></figure><p>另给一个变量使用通配符的例子：</p><ol><li><p>列出一确定文件夹中的所有 <code>.c</code> 文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br></code></pre></td></tr></table></figure></li><li><p>列出(1)中所有文件对应的 <code>.o</code> 文件，在（3）中我们可以看到它是由make自动编译出的:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">patsubst</span> %.<span class="hljs-params">c</span>,%.<span class="hljs-params">o</span>,$(<span class="hljs-params">wildcard</span> <span class="hljs-operator">*</span>.<span class="hljs-params">c</span>)</span>)<br></code></pre></td></tr></table></figure></li><li><p>由(1)(2)两步，可写出编译并链接所有 <code>.c</code> 和 <code>.o</code> 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,$(<span class="hljs-built_in">wildcard</span> *.c)</span>)<br>foo : <span class="hljs-variable">$(objects)</span><br>    cc -o foo <span class="hljs-variable">$(objects)</span><br></code></pre></td></tr></table></figure></li></ol><p>这种用法由关键字“wildcard”，“patsubst”指出，关于Makefile的关键字，我们将在后面讨论。</p><h2 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p><p>Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">VPATH</span> = src:../headers<br></code></pre></td></tr></table></figure><p>上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。<strong>目录由“冒号”分隔</strong>。（当然，当前目录永远是最高优先搜索的地方）</p><p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p><ul><li><p><code>vpath &lt;pattern&gt; &lt;directories&gt;</code></p><p>为符合模式<pattern>的文件指定搜索目录<directories>。</p></li><li><p><code>vpath &lt;pattern&gt;</code></p><p>清除符合模式<pattern>的文件的搜索目录。</p></li><li><p><code>vpath</code></p><p>清除所有已被设置好了的文件搜索目录。</p></li></ul><p>vapth使用方法中的<pattern>需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配零或若干字符，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了&lt; pattern&gt;的文件集的搜索的目录。例如：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">vpath %<span class="hljs-string">.h</span> <span class="hljs-string">../headers</span><br></code></pre></td></tr></table></figure><p>该语句表示，要求make在“../headers”目录下搜索所有以 <code>.h</code> 结尾的文件。（如果某文件在当前目录没有找到的话）</p><p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<pattern> ，或是被重复了的<pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">vpath %</span>.c foo<br><span class="hljs-built_in">vpath %</span>   blish<br><span class="hljs-built_in">vpath %</span>.c bar<br></code></pre></td></tr></table></figure><p>其表示 <code>.c</code> 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">vpath %</span>.c foo:bar<br><span class="hljs-built_in">vpath %</span>   blish<br></code></pre></td></tr></table></figure><p>而上面的语句则表示 <code>.c</code> 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">clean:</span><br>    rm *.o temp<br></code></pre></td></tr></table></figure><p>正像我们前面例子中的“clean”一样，既然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）</p><p>因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p><p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”（伪造的，假的）来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">.PHONY : <span class="hljs-type">clean</span><br></code></pre></td></tr></table></figure><p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">.PHONY : <span class="hljs-type">clean</span><br>clean :<br>    <span class="hljs-type">rm</span> *.o temp<br></code></pre></td></tr></table></figure><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">all : prog1 prog2 prog3<br><span class="hljs-selector-class">.PHONY</span> : all<br><br>prog1 : prog1<span class="hljs-selector-class">.o</span> utils<span class="hljs-selector-class">.o</span><br>    cc -o prog1 prog1<span class="hljs-selector-class">.o</span> utils<span class="hljs-selector-class">.o</span><br><br>prog2 : prog2<span class="hljs-selector-class">.o</span><br>    cc -o prog2 prog2<span class="hljs-selector-class">.o</span><br><br>prog3 : prog3<span class="hljs-selector-class">.o</span> sort<span class="hljs-selector-class">.o</span> utils<span class="hljs-selector-class">.o</span><br>    cc -o prog3 prog3<span class="hljs-selector-class">.o</span> sort<span class="hljs-selector-class">.o</span> utils.o<br></code></pre></td></tr></table></figure><p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，伪目标只是一个标签不会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 <code>.PHONY : all</code> 声明了“all”这个目标为“伪目标”。（注：这里的显式“.PHONY : all” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一个伪目标，执行make不会生成“all”文件，而执行后面的多个目标。建议：显式写出是一个好习惯。）</p><p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">.PHONY : <span class="hljs-type">cleanall</span> cleanobj cleandiff<br><br>cleanall : <span class="hljs-type">cleanobj</span> cleandiff<br>    rm program<br><br>cleanobj :<br>    <span class="hljs-type">rm</span> *.o<br><br>cleandiff :<br>    <span class="hljs-type">rm</span> *.diff<br></code></pre></td></tr></table></figure><p>“make cleanall”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p><h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令不是同一个，这可能会给我们带来麻烦，不过好在我们可以使用一个自动化变量 <code>$@</code> （关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">bigoutput littleoutput : text<span class="hljs-variable">.g</span><br>    <span class="hljs-keyword">generate</span> text<span class="hljs-variable">.g</span> -$(subst <span class="hljs-keyword">output</span>,,$@) &gt; $@<br></code></pre></td></tr></table></figure><p>上述规则等价于：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">bigoutput : text<span class="hljs-variable">.g</span><br>    <span class="hljs-keyword">generate</span> text<span class="hljs-variable">.g</span> -big &gt; bigoutput<br>littleoutput : text<span class="hljs-variable">.g</span><br>    <span class="hljs-keyword">generate</span> text<span class="hljs-variable">.g</span> -little &gt; littleoutput<br></code></pre></td></tr></table></figure><p>其中， <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， <code>$@</code> 表示<strong>目标的集合</strong>，就像一个数组， <code>$@</code> 依次取出目标，并执于命令。</p><h2 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br>    ...<br></code></pre></td></tr></table></figure><p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p><p>target-pattern是指明了targets的模式，也就是的目标集模式。</p><p>prereq-patterns是目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p><p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-pattern>定义成 <code>%.o</code> ，意思是我们的<target>;集合中都是以 <code>.o</code> 结尾的，而如果我们的<prereq-patterns>定义成 <code>%.c</code> ，意思是对<target-pattern>所形成的目标集进行二次定义，其计算方法是，取<target-pattern>模式中的 <code>%</code> （也就是去掉了 <code>.o</code> 这个结尾），并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p><p>所以，我们的“目标模式”或是“依赖模式”中都应该有 <code>%</code> 这个字符，如果你的文件名中有 <code>%</code> 那么你可以使用反斜杠 <code>\</code> 进行转义，来标明真实的 <code>%</code> 字符。</p><p>看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br>    <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>上面的例子中，指明了我们的目标从$object中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code> 。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件(在这里是第一个.c文件)， <code>$@</code> 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foo<span class="hljs-selector-class">.o</span> : foo<span class="hljs-selector-class">.c</span><br>    $(CC) -c $(CFLAGS) foo<span class="hljs-selector-class">.c</span> -o foo<span class="hljs-selector-class">.o</span><br>bar<span class="hljs-selector-class">.o</span> : bar<span class="hljs-selector-class">.c</span><br>    $(CC) -c $(CFLAGS) bar<span class="hljs-selector-class">.c</span> -o bar.o<br></code></pre></td></tr></table></figure><p>试想，如果我们的 <code>%.o</code> 有几百个，那么我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会是一个很强大的功能。再看一个例子：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel">files = foo.elc bar.o lose.o<br>#在files中保留下来.o<br>$(<span class="hljs-keyword">filter</span> %.o,$(files)): %.o: %.c<br>    $(CC) -c $(CFLAGS) $&lt; -o $@<br>$(<span class="hljs-keyword">filter</span> %.elc,$(files)): %.elc: %.el<br>    emacs -f batch-byte-compile $&lt;<br></code></pre></td></tr></table></figure><p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤“$files”集，只要其中模式为“%.o”的内容。其它的内容，我就不用多说了吧。这个例子展示了Makefile中更大的弹性。</p><h2 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h2><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句 <code>#include &quot;defs.h&quot;</code> ，那么我们的依赖关系应该是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">cc</span> -M main.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>其输出是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用 <code>-MM</code> 参数，不然， <code>-M</code> 参数会把一些标准库的头文件也包含进来。</p><p>gcc -M main.c的输出是:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">main.o: main.c defs.h <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/stdio.h /u</span>sr<span class="hljs-regexp">/include/</span>features.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/sys/</span>cdefs.h <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/gnu/</span>stubs.h \<br>    <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc-lib/i</span>486-suse-linux<span class="hljs-regexp">/2.95.3/i</span>nclude/stddef.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>types.h <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>pthreadtypes.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>sched.h <span class="hljs-regexp">/usr/i</span>nclude/libio.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/_G_config.h /u</span>sr<span class="hljs-regexp">/include/</span>wchar.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>wchar.h <span class="hljs-regexp">/usr/i</span>nclude/gconv.h \<br>    <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/gcc-lib/i</span>486-suse-linux<span class="hljs-regexp">/2.95.3/i</span>nclude/stdarg.h \<br>    <span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/bits/</span>stdio_lim.h<br></code></pre></td></tr></table></figure><p>gcc -MM main.c的输出则是:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让 Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个 <code>name.c</code> 的文件都生成一个 <code>name.d</code> 的Makefile文件， <strong><code>.d</code> 文件中就存放对应 <code>.c</code> 文件的依赖关系。</strong></p><p>于是，我们可以写出 <code>.c</code> 文件和 <code>.d</code> 文件的依赖关系，并让make自动更新或生成 <code>.d</code> 文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p><p>这里，我们给出了一个模式规则来产生 <code>.d</code> 文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">%.d: %.c<br>    @<span class="hljs-built_in">set</span> <span class="hljs-literal">-e</span>; <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>; \<br>    <span class="hljs-variable">$</span>(CC) <span class="hljs-literal">-M</span> <span class="hljs-variable">$</span>(CPPFLAGS) <span class="hljs-variable">$</span>&lt; &gt; <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>.<span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span>; \<br>    sed <span class="hljs-string">&#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27;</span> &lt; <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>.<span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span> &gt; <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>; \<br>    <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span><span class="hljs-selector-tag">@</span>.<span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件， <code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个C文件是name.c，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入 <code>.d</code> 文件的依赖，即把依赖关系：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>转成：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.d</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs.h<br></code></pre></td></tr></table></figure><p>于是，我们的 <code>.d</code> 文件也会自动更新了，并会自动生成了，当然，你还可以在这个 <code>.d</code> 文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 <code>.d</code> 文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sources = foo.c bar.c<br><br><span class="hljs-keyword">include</span> <span class="hljs-constructor">$(<span class="hljs-params">sources</span>:.<span class="hljs-params">c</span>=.<span class="hljs-params">d</span>)</span><br></code></pre></td></tr></table></figure><p>上述语句中的 <code>$(sources:.c=.d)</code> 中的 <code>.c=.d</code> 的意思是做一个替换，把变量 <code>$(sources)</code> 所有 <code>.c</code> 的字串都替换成 <code>.d</code> ，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次序来载入文件，最先载入的 <code>.d</code> 文件中的目标会成为默认目标。</p><h1 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h1><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以 <code>Tab</code> 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p><p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被 <code>/bin/sh</code> ——UNIX的标准Shell 解释执行的。除非你特别指定一个其它的Shell。Makefile中， <code>#</code> 是注释符，很像C/C++中的 <code>//</code> ，其后的本行字符都被注释。</p><h2 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h2><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">@<span class="hljs-keyword">echo</span> 正在编译XXX模块<span class="hljs-string">......</span><br></code></pre></td></tr></table></figure><p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">echo 正在编译XXX模块<span class="hljs-params">...</span><span class="hljs-params">...</span><br>正在编译XXX模块<span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>如果make执行时，带入make参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p><p>而make参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p><ul><li>示例一：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:<br>    <span class="hljs-built_in">cd</span> /home/hchen<br>    <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><ul><li>示例二：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:<br>    <span class="hljs-built_in">cd</span> /home/hchen; <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><p>当我们执行 <code>make exec</code> 时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。</p><p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如 <code>.exe</code> 、 <code>.com</code> 、 <code>.bat</code> 、 <code>.sh</code> 等后缀。</p><h2 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h2><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p><p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号 <code>-</code> （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">clean:</span><br>    -rm -f *.o<br></code></pre></td></tr></table></figure><p>还有一个全局的办法是，给make加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以 <code>.IGNORE</code> 作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p><p>还有一个要提一下的make的参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p><h2 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h2><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p><p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    cd subdir &amp;&amp; <span class="hljs-variable">$(MAKE)</span><br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    <span class="hljs-variable">$(MAKE)</span> -C subdir<br></code></pre></td></tr></table></figure><p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p><p>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了 <code>-e</code> 参数。</p><p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">export &lt;<span class="hljs-built_in">variable</span> <span class="hljs-params">...</span>&gt;;<br></code></pre></td></tr></table></figure><p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">unexport &lt;<span class="hljs-built_in">variable</span> <span class="hljs-params">...</span>&gt;;<br></code></pre></td></tr></table></figure><p>如：</p><p>示例一：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> variable = value<br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">variable</span> = <span class="hljs-keyword">value</span><br>export <span class="hljs-keyword">variable</span><br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> variable := value<br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">variable</span> := <span class="hljs-keyword">value</span><br>export <span class="hljs-keyword">variable</span><br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> variable += value<br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">variable</span> += <span class="hljs-keyword">value</span><br>export <span class="hljs-keyword">variable</span><br></code></pre></td></tr></table></figure><p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p><p>需要注意的是，有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><p>但是make命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code> （有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">subsystem:</span><br>    cd subdir &amp;&amp; <span class="hljs-variable">$(MAKE)</span> MAKEFLAGS=<br></code></pre></td></tr></table></figure><p>如果你定义了环境变量 <code>MAKEFLAGS</code> ，那么你得确信其中的选项是大家都会用到的，如果其中有 <code>-t</code> , <code>-n</code> 和 <code>-q</code> 参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p><p>还有一个在“嵌套执行”中比较有用的参数， <code>-w</code> 或是 <code>--print-directory</code> 会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用 <code>make -w</code> 来执行，那么当进入该目录时，我们会看到:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">make: Entering directory `<span class="hljs-regexp">/home/</span>hchen<span class="hljs-regexp">/gnu/m</span>ake<span class="hljs-string">&#x27;.</span><br></code></pre></td></tr></table></figure><p>而在完成下层make后离开目录时，我们会看到:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">make: Leaving directory `<span class="hljs-regexp">/home/</span>hchen<span class="hljs-regexp">/gnu/m</span>ake<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>当你使用 <code>-C</code> 参数来指定make下层Makefile时， <code>-w</code> 会被自动打开的。如果参数中有 <code>-s</code> （ <code>--slient</code> ）或是 <code>--no-print-directory</code> ，那么， <code>-w</code> 总是失效的。</p><h2 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h2><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> run-yacc<br>yacc <span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$^</span>)</span><br>mv y.tab.c <span class="hljs-variable">$@</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 <code>define</code> 和 <code>endef</code> 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">foo.c : foo.y<br>    <span class="hljs-constructor">$(<span class="hljs-params">run</span>-<span class="hljs-params">yacc</span>)</span><br></code></pre></td></tr></table></figure><p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的 <code>$^</code> 就是 <code>foo.y</code> ， <code>$@</code> 就是 <code>foo.c</code> （有关这种以 <code>$</code> 开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p><h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h1><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”， “命令”或是Makefile的其它部分中。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p><p>有一些变量是很奇怪字串，如 <code>$&lt;</code> 、 <code>$@</code> 等，这些是自动化变量，我会在后面介绍。</p><h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>&#123;&#125;</code> 把变量给包括起来。如果你要使用真实的 <code>$</code> 字符，那么你需要用 <code>$$</code> 来表示。</p><p>变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">objects = program.o foo.o utils.o<br>program : <span class="hljs-constructor">$(<span class="hljs-params">objects</span>)</span><br>    cc -o program <span class="hljs-constructor">$(<span class="hljs-params">objects</span>)</span><br><br><span class="hljs-constructor">$(<span class="hljs-params">objects</span>)</span> : defs.h<br></code></pre></td></tr></table></figure><p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">foo = c<br>prog.o : prog.<span class="hljs-constructor">$(<span class="hljs-params">foo</span>)</span><br>    <span class="hljs-constructor">$(<span class="hljs-params">foo</span>)</span><span class="hljs-constructor">$(<span class="hljs-params">foo</span>)</span> -<span class="hljs-constructor">$(<span class="hljs-params">foo</span>)</span> prog.<span class="hljs-constructor">$(<span class="hljs-params">foo</span>)</span><br></code></pre></td></tr></table></figure><p>展开后得到：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">prog.o : prog.<span class="hljs-keyword">c</span><br>    <span class="hljs-keyword">cc</span> -<span class="hljs-keyword">c</span> prog.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。</p><p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p><h2 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p><p>先看第一种方式，也就是简单的使用 <code>=</code> 号，在 <code>=</code> 左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">foo = <span class="hljs-variable">$(bar)</span><br>bar = <span class="hljs-variable">$(ugh)</span><br>ugh = Huh?<br><br><span class="hljs-section">all:</span><br>    echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><p>我们执行“make all”将会打出变量 <code>$(foo)</code> 的值是 <code>Huh?</code> （ <code>$(foo)</code> 的值是 <code>$(bar)</code> ， <code>$(bar)</code> 的值是 <code>$(ugh)</code> ， <code>$(ugh)</code> 的值是 <code>Huh?</code> ）可见，变量是可以使用后面的变量来定义的。</p><p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CFLAGS</span> = $(include_dirs) -O<br><span class="hljs-attr">include_dirs</span> = -Ifoo -Ibar<br></code></pre></td></tr></table></figure><p>当 <code>CFLAGS</code> 在命令中被展开时，会是 <code>-Ifoo -Ibar -O</code> 。但这种形式也有不好的地方，那就是递归定义，如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">CFLAGS</span> = $(CFLAGS) -O<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">A</span> = $(B)<br><span class="hljs-attr">B</span> = $(A)<br></code></pre></td></tr></table></figure><p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p><p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是 <code>:=</code> 操作符，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x := foo<br>y := <span class="hljs-variable">$(x)</span> bar<br>x := later<br></code></pre></td></tr></table></figure><p>其等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">y := foo bar<br>x := later<br></code></pre></td></tr></table></figure><p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">y := <span class="hljs-variable">$(x)</span> bar<br>x := foo<br></code></pre></td></tr></table></figure><p>那么，y的值是“bar”，而不是“foo bar”。</p><p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">ifeq (0,<span class="hljs-variable">$&#123;MAKELEVEL&#125;</span>)<br>cur-<span class="hljs-keyword">dir</span>   := $(<span class="hljs-keyword">shell</span> <span class="hljs-keyword">pwd</span>)<br>whoami    := $(<span class="hljs-keyword">shell</span> whoami)<br>host-<span class="hljs-keyword">type</span> := $(<span class="hljs-keyword">shell</span> <span class="hljs-keyword">arch</span>)<br>MAKE := <span class="hljs-variable">$&#123;MAKE&#125;</span> host-<span class="hljs-keyword">type</span>=<span class="hljs-variable">$&#123;host</span>-<span class="hljs-keyword">type</span>&#125; whoami=<span class="hljs-variable">$&#123;whoami&#125;</span><br>endif<br></code></pre></td></tr></table></figure><p>关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p><p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">nullstring :=<br>space := <span class="hljs-variable">$(nullstring)</span> <span class="hljs-comment"># end of the line</span><br></code></pre></td></tr></table></figure><p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">dir := <span class="hljs-regexp">/foo/</span>bar    <span class="hljs-comment"># directory to put the frobs in</span><br></code></pre></td></tr></table></figure><p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p><p>还有一个比较有用的操作符是 <code>?=</code> ，先看示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">FOO <span class="hljs-string">?=</span> bar<br></code></pre></td></tr></table></figure><p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">ife<span class="hljs-string">q ($(origin FOO)</span>, undefined)<br>    FOO = bar<br>endif<br></code></pre></td></tr></table></figure><h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。</p><p>我们可以替换变量中的共有的部分，其格式是 <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p><p>还是看一个示例吧：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">foo := <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.o</span> c<span class="hljs-selector-class">.o</span><br>bar := $(foo:.o=.c)<br></code></pre></td></tr></table></figure><p>这个示例中，我们先定义了一个 <code>$(foo)</code> 变量，而第二行的意思是把 <code>$(foo)</code> 中所有以 <code>.o</code> 字串“结尾”全部替换成 <code>.c</code> ，所以我们的 <code>$(bar)</code> 的值就是“a.c b.c c.c”。</p><p>另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">foo :<span class="hljs-operator">=</span> a.o b.o <span class="hljs-keyword">c</span>.o<br>bar :<span class="hljs-operator">=</span> $(foo:<span class="hljs-variable">%.o</span><span class="hljs-operator">=</span><span class="hljs-variable">%.c</span>)<br></code></pre></td></tr></table></figure><p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个 <code>%</code> 字符，这个例子同样让 <code>$(bar)</code> 变量的值为“a.c b.c c.c”。</p><p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = y<br>y = z<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）</p><p>我们还可以使用更多的层次：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = y<br>y = z<br>z = u<br>a := $($(<span class="hljs-variable">$(x)</span>))<br></code></pre></td></tr></table></figure><p>这里的 <code>$(a)</code> 的值是“u”，相关的推导留给读者自己去做吧。</p><p>让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = <span class="hljs-variable">$(y)</span><br>y = z<br>z = Hello<br>a := $(<span class="hljs-variable">$(x)</span>)<br></code></pre></td></tr></table></figure><p>这里的 <code>$($(x))</code> 被替换成了 <code>$($(y))</code> ，因为 <code>$(y)</code> 值是“z”，所以，最终结果是： <code>a:=$(z)</code> ，也就是“Hello”。</p><p>再复杂一点，我们再加上函数：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">x = variable1<br>variable2 := Hello<br>y = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> 1,2,<span class="hljs-variable">$(x)</span>)</span><br>z = y<br>a := $($(<span class="hljs-variable">$(z)</span>))<br></code></pre></td></tr></table></figure><p>这个例子中， <code>$($($(z)))</code> 扩展为 <code>$($(y))</code> ，而其再次被扩展为 <code>$($(subst 1,2,$(x)))</code> 。 <code>$(x)</code> 的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成 “variable2”，再取其值，所以，最终， <code>$(a)</code> 的值就是 <code>$(variable2)</code> 的值——“Hello”。（喔，好不容易）</p><p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">first_second</span> = Hello<br><span class="hljs-attr">a</span> = first<br><span class="hljs-attr">b</span> = second<br><span class="hljs-attr">all</span> = $(<span class="hljs-variable">$a_</span><span class="hljs-variable">$b</span>)<br></code></pre></td></tr></table></figure><p>这里的 <code>$a_$b</code> 组成了“first_second”，于是， <code>$(all)</code> 的值就是“Hello”。</p><p>再来看看结合第一种技术的例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a_objects := <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.o</span> c<span class="hljs-selector-class">.o</span><br><span class="hljs-number">1</span>_objects := <span class="hljs-number">1</span><span class="hljs-selector-class">.o</span> <span class="hljs-number">2</span><span class="hljs-selector-class">.o</span> <span class="hljs-number">3</span><span class="hljs-selector-class">.o</span><br><br>sources := $($(a1)_objects:.o=.c)<br></code></pre></td></tr></table></figure><p>这个例子中，如果 <code>$(a1)</code> 的值是“a”的话，那么， <code>$(sources)</code> 的值就是“a.c b.c c.c”；如果 <code>$(a1)</code> 的值是“1”，那么 <code>$(sources)</code> 的值是“1.c 2.c 3.c”。</p><p>再来看一个这种技术和“函数”与“条件语句”一同使用的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">ifdef do_sort<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> := <span class="hljs-title">sort</span></span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> := <span class="hljs-title">strip</span></span><br>endif<br><br>bar := a d b g q c<br><br>foo := $($(<span class="hljs-function"><span class="hljs-keyword">func</span>) $<span class="hljs-params">(bar)</span>)</span><br></code></pre></td></tr></table></figure><p>这个示例中，如果定义了“do_sort”，那么： <code>foo := $(sort a d b g q c)</code> ，于是 <code>$(foo)</code> 的值就是 “a b c d g q”，而如果没有定义“do_sort”，那么： <code>foo := $(strip a d b g q c)</code> ，调用的就是strip函数。</p><p>当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> = foo<br><span class="hljs-variable">$</span>(<span class="hljs-built_in">dir</span>)_sources := <span class="hljs-variable">$</span>(wildcard <span class="hljs-variable">$</span>(<span class="hljs-built_in">dir</span>)/*.c)<br>define <span class="hljs-variable">$</span>(<span class="hljs-built_in">dir</span>)_print<br>lpr <span class="hljs-variable">$</span>(<span class="hljs-variable">$</span>(<span class="hljs-built_in">dir</span>)_sources)<br>endef<br></code></pre></td></tr></table></figure><p>这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。</p><h2 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h2><p>我们可以使用 <code>+=</code> 操作符给变量追加值，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">objects = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> foo<span class="hljs-selector-class">.o</span> bar<span class="hljs-selector-class">.o</span> utils<span class="hljs-selector-class">.o</span><br>objects += another.o<br></code></pre></td></tr></table></figure><p>于是，我们的 <code>$(objects)</code> 值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p><p>使用 <code>+=</code> 操作符，可以模拟为下面的这种例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">objects = <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> foo<span class="hljs-selector-class">.o</span> bar<span class="hljs-selector-class">.o</span> utils<span class="hljs-selector-class">.o</span><br>objects := $(objects) another.o<br></code></pre></td></tr></table></figure><p>所不同的是，用 <code>+=</code> 更为简洁。</p><p>如果变量之前没有定义过，那么， <code>+=</code> 会自动变成 <code>=</code> ，如果前面有变量定义，那么 <code>+=</code> 会继承于前次操作的赋值符。如果前一次的是 <code>:=</code> ，那么 <code>+=</code> 会以 <code>:=</code> 作为其赋值符，如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">variable</span> := value<br><span class="hljs-keyword">variable</span> <span class="hljs-comment">+= more</span><br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">variable</span> := value<br><span class="hljs-keyword">variable</span> <span class="hljs-comment">:= $(variable) more</span><br></code></pre></td></tr></table></figure><p>但如果是这种情况：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">variable</span> = value<br><span class="hljs-keyword">variable</span> <span class="hljs-comment">+= more</span><br></code></pre></td></tr></table></figure><p>由于前次的赋值符是 <code>=</code> ，所以 <code>+=</code> 也会以 <code>=</code> 来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p><h2 id="override-指示符"><a href="#override-指示符" class="headerlink" title="override 指示符"></a>override 指示符</h2><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">override <span class="hljs-tag">&lt;<span class="hljs-name">variable</span>&gt;</span>; = <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>;<br><br>override <span class="hljs-tag">&lt;<span class="hljs-name">variable</span>&gt;</span>; := <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>当然，你还可以追加:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">override &lt;variable&gt;<span class="hljs-comment">; += &lt;more text&gt;;</span><br></code></pre></td></tr></table></figure><p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用override指示符，如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">override</span> <span class="hljs-keyword">define</span> foo<br>bar<br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><h2 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h2><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p><p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 <code>Tab</code> 键开头，那么make 就不会把其认为是命令。</p><p>下面的这个示例展示了define的用法:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">define</span> two-lines<br>echo foo<br>echo <span class="hljs-variable">$(bar)</span><br><span class="hljs-keyword">endef</span><br></code></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><p>因此，如果我们在环境变量中设置了 <code>CFLAGS</code> 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p><p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p><p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p><h2 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h2><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如 <code>$&lt;</code> 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p><p>当然，我也同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p><p>其语法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">...</span>&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span>;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">target</span> <span class="hljs-attr">...</span>&gt;</span> : overide <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span><br></code></pre></td></tr></table></figure><p><variable-assignment>;可以是前面讲过的各种赋值表达式，如 <code>=</code> 、 <code>:=</code> 、 <code>+= `` 或是 ``?=</code> 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p><p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">prog : CFLAGS = -g<br>prog : prog<span class="hljs-selector-class">.o</span> foo<span class="hljs-selector-class">.o</span> bar<span class="hljs-selector-class">.o</span><br>    $(CC) $(CFLAGS) prog<span class="hljs-selector-class">.o</span> foo<span class="hljs-selector-class">.o</span> bar<span class="hljs-selector-class">.o</span><br><br>prog<span class="hljs-selector-class">.o</span> : prog<span class="hljs-selector-class">.c</span><br>    $(CC) $(CFLAGS) prog<span class="hljs-selector-class">.c</span><br><br>foo<span class="hljs-selector-class">.o</span> : foo<span class="hljs-selector-class">.c</span><br>    $(CC) $(CFLAGS) foo<span class="hljs-selector-class">.c</span><br><br>bar<span class="hljs-selector-class">.o</span> : bar<span class="hljs-selector-class">.c</span><br>    $(CC) $(CFLAGS) bar.c<br></code></pre></td></tr></table></figure><p>在这个示例中，不管全局的 <code>$(CFLAGS)</code> 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， <code>$(CFLAGS)</code> 的值都是 <code>-g</code></p><h2 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h2><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p><p>我们知道，make的“模式”一般是至少含有一个 <code>%</code> 的，所以，我们可以以如下方式给所有以 <code>.o</code> 结尾的目标定义目标变量：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-class">.o</span></span> : CFLAGS = -O<br></code></pre></td></tr></table></figure><p>同样，模式变量的语法和“目标变量”一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">...</span>&gt;</span>; : <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span>;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span> <span class="hljs-attr">...</span>&gt;</span>; : override <span class="hljs-tag">&lt;<span class="hljs-name">variable-assignment</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl</title>
    <link href="/2021/08/01/openssl/"/>
    <url>/2021/08/01/openssl/</url>
    
    <content type="html"><![CDATA[<h4 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h4><p>SSL是Secure Sockets Layer（安全套接层协议）的缩写，其目标是保证两个应用间通信的保密性和可靠性,可在服务器端和用户端同时实现支持。已经成为Internet上保密通讯的工业标准。SSL能使用户/服务器应用之间的通信不被攻击者窃听，并且始终对服务器进行认证，还可选择对用户进行认证。SSL协议要求建立在可靠的传输层协议(TCP)之上。SSL协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET等)能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p><h4 id="密钥证书管理"><a href="#密钥证书管理" class="headerlink" title="密钥证书管理"></a>密钥证书管理</h4><p>密钥和证书管理是PKI的一个重要组成部分，OpenSSL为之提供了丰富的功能，支持多种标准。<br>首先，OpenSSL实现了ASN.1的证书和密钥相关标准，提供了对证书、公钥、私钥、证书请求以及CRL等数据对象的DER、PEM和BASE64的编解码功能。OpenSSL提供了产生各种公开密钥对和对称密钥的方法、函数和应用程序，同时提供了对公钥和私钥的DER编解码功能。并实现了私钥的PKCS#12和PKCS#8的编解码功能。OpenSSL在标准中提供了对私钥的加密保护功能，使得密钥可以安全地进行存储和分发。<br>在此基础上，OpenSSL实现了对证书的X.509标准编解码、PKCS#12格式的编解码以及PKCS#7的编解码功能。并提供了一种文本数据库，支持证书的管理功能，包括证书密钥产生、请求产生、证书签发、吊销和验证等功能。<br>事实上，OpenSSL提供的CA应用程序就是一个小型的证书管理中心（CA），实现了证书签发的整个流程和证书管理的大部分机制。</p><h4 id="SSL和TLS协议"><a href="#SSL和TLS协议" class="headerlink" title="SSL和TLS协议"></a>SSL和TLS协议</h4><p>OpenSSL实现了SSL协议的SSLv2和SSLv3，支持了其中绝大部分算法协议。OpenSSL也实现了TLSv1.0，TLS是SSLv3的标准化版，虽然区别不大，但毕竟有很多细节不尽相同。<br>虽然已经有众多的软件实现了OpenSSL的功能，但是OpenSSL里面实现的SSL协议能够让我们对SSL协议有一个更加清楚的认识，因为至少存在两点：一是OpenSSL实现的SSL协议是开放源代码的，我们可以追究SSL协议实现的每一个细节；二是OpenSSL实现的SSL协议是纯粹的SSL协议，没有跟其它协议（如HTTP）协议结合在一起，澄清了SSL协议的本来面目。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>OpenSSL一共提供了8种对称加密算法，其中7种是分组加密算法，仅有的一种流加密算法是RC4。这7种分组加密算法分别是AES、DES、Blowfish、CAST、IDEA、RC2、RC5，都支持电子密码本模式（ECB）、加密分组链接模式（CBC）、加密反馈模式（CFB）和输出反馈模式（OFB）四种常用的分组密码加密模式。其中，AES使用的加密反馈模式（CFB）和输出反馈模式（OFB）分组长度是128位，其它算法使用的则是64位。事实上，DES算法里面不仅仅是常用的DES算法，还支持三个密钥和两个密钥3DES算法。<br>非对称加密<br>OpenSSL一共实现了4种非对称加密算法，包括DH算法、RSA算法、DSA算法和椭圆曲线算法（EC）。DH算法一般用于密钥交换。RSA算法既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密。DSA算法则一般只用于数字签名。<br>信息摘要<br>OpenSSL实现了5种信息摘要算法，分别是MD2、MD5、MDC2、SHA（SHA1）和RIPEMD。SHA算法事实上包括了SHA和SHA1两种信息摘要算法。此外，OpenSSL还实现了DSS标准中规定的两种信息摘要算法DSS和DSS1。</p><h4 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h4><p><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">参考文章1</a> <a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">2</a><br>原理如文章中所述，只看应用的话，步骤如下：<br>随机选择两个不相等的质数p和q。越大越难破解，假如选择了61与53，二者的乘积为3233。这里应该需要生成质数的算法<br>计算欧拉函数值，φ(3233)等于60×52，即3120。这里是(p-1)(q-1)。所以计算这一步应该比较简单。<br>随机选一个小于φ(3233)的数。（这个数根据欧拉定理肯定与φ(3233)互质）<br>计算e对于φ(n)的模反元素d。这里求解也需要一个函数用来解一个二元一次方程的一个解。这里得到2753<br>公钥就是 (3233,17)，私钥就是（3233, 2753），公钥都能知道，私钥只有自己知道。<br>谁想给自己发信息就先用公钥加密，给自己发过来后自己再用私钥解。<br>想发送65的话计算65的17次方取余3233是2790，然后把2790发过去。收到2790后用私钥来解，2790的2753次方取余3233结果是65，这就是解码得到的。这样看的话，这一步重要的地方在于乘方，可以关注这里的优化方法。</p><h4 id="DSA算法"><a href="#DSA算法" class="headerlink" title="DSA算法"></a>DSA算法</h4><p><a href="https://zhuanlan.zhihu.com/p/347025157">参考文章</a>     过程图如下：</p><p>DSA是一种更高级的验证方式，它是一种公开密钥算法，不能用来加密数据，一般用于数字签名和认证。DSA 不单单只有公钥、私钥，还有数字签名。私钥加密生成数字签名，公钥验证数据及签名。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性，包括数据的完整性以及数据发送者的身份。如果数据和签名不匹配则认为验证失败。数字签名的作用就是校验数据在传输过程中不被修改。<br>这里的公钥和私钥与之RSA的正好相反，私钥用来加密，私钥的那个数是随机选的（RSA中公钥的随机选的）因为在自己手里保密的，所以还叫私钥。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cache知识总结</title>
    <link href="/2021/07/04/cache%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/04/cache%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="现代体系结构上的unix系统第二章"><a href="#现代体系结构上的unix系统第二章" class="headerlink" title="现代体系结构上的unix系统第二章"></a>现代体系结构上的unix系统第二章</h3><p>第二章主要对高速缓存系统进行了概述，看的受益很多，主要是在书上做了勾画，这里简单记一些要点。<br>寄存器贵，内存慢，价格与速度均介于二者之间的缓存诞生了<br>由于数据的局部性原理，缓存能够取得比较好的效果<br>cache只是主存储器的一个子集，怎么表示存取了哪些，哪些被修改了主要靠标记(tagging)，平时说的cache line大小是数据大小，不包含标记大小。<br>替换策略主要是LRU、随机替换之类的<br>写入策略分直通与写回。直通改了缓存的时候也改主存，写回改了缓存过一段时间再改主存<br>写回会有一致性问题，所以需要标记有没有更改，并且在一些操作前得刷新<br>直接映射，散列算法。<br>双路组相连，n 路组相连<br>基本上都支持无缓存的操作，cpu直接存取主存<br>现在x86基本上采用上一级缓存的内容不包含在下一层。arm分情况。</p><h3 id="下面是网页知识总结："><a href="#下面是网页知识总结：" class="headerlink" title="下面是网页知识总结："></a>下面是网页知识总结：</h3><p><a href="https://zhuanlan.zhihu.com/p/102293437">链接</a></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h4 id="多级cache存储结构"><a href="#多级cache存储结构" class="headerlink" title="多级cache存储结构"></a>多级cache存储结构</h4><p>当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。等级越高，速度越慢，容量越大。但是速度相比较主存而言，依然很快。不同等级cache速度之间关系如下：</p><p>Cortex-A53架构上各级cache之间的硬件抽象框图如下：</p><p>在Cortex-A53架构上，L1 cache分为单独的instruction cache（ICache）和data cache（DCache）。L1 cache是CPU私有的，每个CPU都有一个L1 cache。一个cluster 内的所有CPU共享一个L2 cache，L2 cache不区分指令和数据，都可以缓存。所有cluster之间共享L3 cache。L3 cache通过总线和主存相连。<br>inclusive与exclusive<br>下图略过L3</p><p>CPU要访问的数据在cache中有缓存，称为“命中” (hit)，反之则称为“缺失” (miss)。<br>当CPU试图从某地址load数据时，首先从L1 cache中查询是否命中，如果命中则把数据返回给CPU。如果L1 cache缺失，则继续从L2 cache中查找。当L2 cache命中时，数据会返回给L1 cache以及CPU。如果L2 cache也缺失，很不幸，我们需要从主存中load数据，将数据返回给L2 cache、L1 cache及CPU。这种多级cache的工作方式称之为inclusive cache。某一地址的数据可能存在多级缓存中。与inclusive cache对应的是exclusive cache，这种cache保证某一地址的数据缓存只会存在于多级cache其中一级。也就是说，任意地址的数据不可能同时在L1和L2 cache中缓存。</p><h4 id="直接映射缓存"><a href="#直接映射缓存" class="headerlink" title="直接映射缓存"></a>直接映射缓存</h4><p>cache的大小称之为cahe size，代表cache可以缓存最大数据的大小。我们将cache平均分成相等的很多块，每一个块大小称之为cache line，其大小是cache line size。例如一个64 Bytes大小的cache。如果我们将64 Bytes平均分成64块，那么cache line就是1字节，总共64行cache line。<br>cache line是cache和主存之间数据传输的最小单位。如果cache缺失，那么cache控制器会从主存中一次性的load cache line大小的数据到cache中。<br>怎么判断想要的数据我们有没有存，我们要把要访问的地址存取下来，按照散列找到cache中的对应位置，再检查地址到底匹不匹配，如果匹配就说明就是它。<br>两路组相连，n路组相连，全相连缓存<br>注意更新策略即可。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>写直通与写回</p><h4 id="cache组织方式"><a href="#cache组织方式" class="headerlink" title="cache组织方式"></a>cache组织方式</h4><p>我们都知道cache控制器根据地址查找判断是否命中，这里的地址究竟是虚拟地址(virtual address，VA)还是物理地址(physical address，PA)？我们应该清楚CPU发出对某个地址的数据访问，这个地址其实是虚拟地址，虚拟地址经过MMU转换成物理地址，最终从这个物理地址读取数据。因此cache的硬件设计既可以采用虚拟地址也可以采用物理地址甚至是取两者地址部分组合作为查找cache的依据。</p><h4 id="虚拟高速缓存（VIVT）"><a href="#虚拟高速缓存（VIVT）" class="headerlink" title="虚拟高速缓存（VIVT）"></a>虚拟高速缓存（VIVT）</h4><p>虚拟地址直接送到cache控制器，如果cache hit。直接从cache中返回数据给CPU。如果cache miss，则把虚拟地址发往MMU，经过MMU转换成物理地址，根据物理地址从主存(main memory)读取数据。由于我们根据虚拟地址查找高速缓存，所以我们是用虚拟地址中部分位域作为索引(index)，找到对应的的cacheline。然后根据虚拟地址中部分位域作为标记(tag)来判断cache是否命中。因此，我们针对这种index和tag都取自虚拟地址的高速缓存称为虚拟高速缓存，简称VIVT(Virtually Indexed Virtually Tagged)。另外，我们复习下cache控制器查找数据以及判断是否命中的规则：通过index查找对应的cacheline，通过tag判断是否命中cache。 虚拟高速缓存的优点是不需要每次读取或者写入操作的时候把虚拟地址经过MMU转换为物理地址，这在一定的程度上提升了访问cache的速度，毕竟MMU转换虚拟地址需要时间。同时硬件设计也更加简单。但是，正是使用了虚拟地址作为tag，所以引入很多软件使用上的问题。 操作系统在管理高速缓存正确工作的过程中，主要会面临两个问题。歧义(ambiguity)和别名(alias)。为了保证系统的正确工作，操作系统负责避免出现歧义和别名。</p><h5 id="歧义-ambiguity"><a href="#歧义-ambiguity" class="headerlink" title="歧义(ambiguity)"></a>歧义(ambiguity)</h5><p>简单来说就是不同进程有相同的虚拟地址，处理方法就是切换进程的时候刷新缓存，代价大<br>歧义是指不同的数据在cache中具有相同的tag和index。cache控制器判断是否命中cache的依据就是tag和index，因此这种情况下，cache控制器根本没办法区分不同的数据。这就产生了歧义。什么情况下发生歧义呢？我们知道不同的物理地址存储不同的数据，只要相同的虚拟地址映射不同的物理地址就会出现歧义。例如两个互不相干的进程，就可能出现相同的虚拟地址映射不同的物理地址。假设A进程虚拟地址0x4000映射物理地址0x2000。B进程虚拟地址0x4000映射物理地址0x3000。当A进程运行时，访问0x4000地址会将物理地址0x2000的数据加载到cacheline中。当A进程切换到B进程的时候，B进程访问0x4000会怎样？当然是会cache hit，此时B进程就访问了错误的数据，B进程本来想得到物理地址0x3000对应的数据，但是却由于cache hit得到了物理地址0x2000的数据。操作系统如何避免歧义的发生呢？当我们切换进程的时候，可以选择flush所有的cache。flush cache操作有两种： - 使主存储器有效。针对write back高速缓存，首先应该使主存储器有效，保证已经修改数据的cacheline写回主存储器，避免修改的数据丢失。 - 使高速缓存无效。保证切换后的进程不会错误的命中上一个进程的缓存数据。<br>因此，切换后的进程刚开始执行的时候，将会由于大量的cache miss导致性能损失。所以，VIVT高速缓存明显的缺点之一就是经常需要flush cache以保证歧义不会发生，最终导致性能的损失。VIVT高速缓存除了面对歧义问题外，还面临另一个问题：别名(alias)。</p><h5 id="别名-alias"><a href="#别名-alias" class="headerlink" title="别名(alias)"></a>别名(alias)</h5><p>简单来说就是不同的虚拟地址可以映射向相同的物理地址，那写回的时候就会面临两个也许不同的写回<br>当不同的虚拟地址映射相同的物理地址，而这些虚拟地址的index不同，此时就发生了别名现象(多个虚拟地址被称为别名)。通俗点来说就是指同一个物理地址的数据被加载到不同的cacheline中就会出现别名现象。 考虑这样的一个例子。虚拟地址0x2000和0x4000都映射到相同的物理地址0x8000。这意味着进程既可以从0x2000读取数据，也能从地址0x4000读取数据。假设系统使用的是直接映射VIVT高速缓存，cache更新策略采用写回机制，并且使用虚拟地址的位&lt;15…4&gt;作为index。那么虚拟地址0x2000和虚拟地址0x4000的index分别是0x200和0x400。这意味同一个物理地址的数据会加载到不同的cacheline。假设物理地址0x8000存储的数据是0x1234。程序先访问0x2000把数据0x1234加载到第0x200(index)行cacheline中。接着访问0x4000，会将0x1234再一次的加载到第0x400(index)行cacheline中。现在程序将0x2000地址数据修改成0x5678。由于采用的是写回策略，因此修改的数据依然躺在cacheline中。当程序访问0x4000的时候由于cache hit导致读取到旧的数据0x1234。这就造成了数据不一致现象，这不是我们想要的结果。可以选择下面的方法避免这个问题：那就是针对共享数据采用nocache，或者采用其他方法。</p><h4 id="物理高速缓存-PIPT"><a href="#物理高速缓存-PIPT" class="headerlink" title="物理高速缓存(PIPT)"></a>物理高速缓存(PIPT)</h4><p>基于对VIVT高速缓存的认识，我们知道VIVT高速缓存存在歧义和名别两大问题。主要问题原因是：tag取自虚拟地址导致歧义，index取自虚拟地址导致别名。所以，如果想让操作系统少操心，最简单的方法是tag和index都取自物理地址。物理的地址tag部分是独一无二的，因此肯定不会导致歧义。而针对同一个物理地址，index也是唯一的，因此加载到cache中也是唯一的cacheline，所以也不会存在别名。我们称这种cache为物理高速缓存，简称PIPT(Physically Indexed Physically Tagged)。PIPT工作原理如下图所示。</p><p>CPU发出的虚拟地址经过MMU转换成物理地址，物理地址发往cache控制器查找确认是否命中cache。虽然PIPT方式在软件层面基本不需要维护，但是硬件设计上比VIVT复杂很多。因此硬件成本也更高。同时，由于虚拟地址每次都要翻译成物理地址，因此在查找性能上没有VIVT方式简洁高效，毕竟PIPT方式需要等待虚拟地址转换物理地址完成后才能去查找cache。顺便提一下，为了加快MMU翻译虚拟地址的速度，硬件上也会加入一块cache，作用是缓存虚拟地址和物理地址的映射关系，这块cache称之为TLB(Translation Lookaside Buffer)。当MMU需要转换虚拟地址时，首先从TLB中查找，如果cache hit，则直接返回物理地址。如果cache miss则需要MMU查找页表。这样就加快了虚拟地址转换物理地址的速度。如果系统采用的PIPT的cache，那么软件层面基本不需要任何的维护就可以避免歧义和别名问题。这是PIPT最大的优点。现在的CPU很多都是采用PIPT高速缓存设计。在Linux内核中，可以看到针对PIPT高速缓存的管理函数都是空函数，无需任何的管理。</p><h4 id="物理标记的虚拟高速缓存-VIPT"><a href="#物理标记的虚拟高速缓存-VIPT" class="headerlink" title="物理标记的虚拟高速缓存(VIPT)"></a>物理标记的虚拟高速缓存(VIPT)</h4><p>为了提升cache查找性能，我们不想等到虚拟地址转换物理地址完成后才能查找cache。因此，我们可以使用虚拟地址对应的index位查找cache，与此同时(硬件上同时进行)将虚拟地址发到MMU转换成物理地址。当MMU转换完成，同时cache控制器也查找完成，此时比较cacheline对应的tag和物理地址tag域，以此判断是否命中cache。我们称这种高速缓存为VIPT(Virtually Indexed Physically Tagged)。</p><p>VIPT以物理地址部分位作为tag，因此我们不会存在歧义问题。但是，采用虚拟地址作为index，所以可能依然存在别名问题。是否存在别名问题，需要考虑cache的结构，我们需要分情况考虑。</p><h5 id="VIPT-Cache为什么不存在歧义"><a href="#VIPT-Cache为什么不存在歧义" class="headerlink" title="VIPT Cache为什么不存在歧义"></a>VIPT Cache为什么不存在歧义</h5><p>在这里重点介绍下为什么VIPT Cache不存在歧义。假设以32位CPU为例，页表映射最小单位是4KB。我们假设虚拟地址&lt;12:4&gt;位(这是一个有别名问题的VIPT Cache)作为index，于此同时将虚拟地址&lt;31:12&gt;发送到MMU转换得到物理地址的&lt;31:12&gt;，这里我们把&lt;31:12&gt;作为tag，并不是&lt;31:13&gt;。这地方很关键，也就是说VIPT的tag取决于物理页大小的剩余位数，而不是去掉index和offset的剩余位数。物理tag是惟一的，所以不存在歧义。</p><h5 id="VIPT-Cache什么情况不存在别名"><a href="#VIPT-Cache什么情况不存在别名" class="headerlink" title="VIPT Cache什么情况不存在别名"></a>VIPT Cache什么情况不存在别名</h5><p>我们知道VIPT的优点是查找cache和MMU转换虚拟地址同时进行，所以性能上有所提升。歧义问题虽然不存在了，但是别名问题依旧可能存在，那么什么情况下别名问题不会存在呢？Linux系统中映射最小的单位是页，一页大小是4KB。那么意味着虚拟地址和其映射的物理地址的位&lt;11…0&gt;是一样的。针对直接映射高速缓存，如果cache的size小于等于4KB，是否就意味着无论使用虚拟地址还是物理地址的低位查找cache结果都是一样呢？是的，因为虚拟地址和物理地址对应的index是一样的。这种情况，VIPT实际上相当于PIPT，软件维护上和PIPT一样。如果示例是一个四路组相连高速缓存呢？只要满足一路的cache的大小小于等于4KB，那么也不会出现别名问题。</p><h5 id="VIPT-Cache的别名问题"><a href="#VIPT-Cache的别名问题" class="headerlink" title="VIPT Cache的别名问题"></a>VIPT Cache的别名问题</h5><p>假设系统使用的是直接映射高速缓存，cache大小是8KB，cacheline大小是256字节。这种情况下的VIPT就存在别名问题。因为index来自虚拟地址位&lt;12…8&gt;，虚拟地址和物理地址的位&lt;11…8&gt;是一样的，但是bit12却不一定相等。 假设虚拟地址0x0000和虚拟地址0x1000都映射相同的物理地址0x4000。那么程序读取0x0000时，系统将会从物理地址0x4000的数据加载到第0x00行cacheline。然后程序读取0x1000数据，再次把物理地址0x4000的数据加载到第0x10行cacheline。这不，别名出现了。相同物理地址的数据被加载到不同cacheline中。</p><h5 id="如何解决VIPT-Cache别名问题"><a href="#如何解决VIPT-Cache别名问题" class="headerlink" title="如何解决VIPT Cache别名问题"></a>如何解决VIPT Cache别名问题</h5><p>我们接着上面的例子说明。首先出现问题的场景是共享映射，也就是多个虚拟地址映射同一个物理地址才可能出现问题。我们需要想办法避免相同的物理地址数据加载到不同的cacheline中。如何做到呢？那我们就避免上个例子中0x1000映射0x4000的情况发生。我们可以将虚拟地址0x2000映射到物理地址0x4000，而不是用虚拟地址0x1000。0x2000对应第0x00行cacheline，这样就避免了别名现象出现。因此，在建立共享映射的时候，返回的虚拟地址都是按照cache大小对齐的地址，这样就没问题了。如果是多路组相连高速缓存的话，返回的虚拟地址必须是满足一路cache大小对齐。在Linux的实现中，就是通过这种方法解决别名问题。</p><h5 id="不存在的PIVT高速缓存"><a href="#不存在的PIVT高速缓存" class="headerlink" title="不存在的PIVT高速缓存"></a>不存在的PIVT高速缓存</h5><p>按照排列组合来说，应该还存在一种PIVT方式的高速缓存。因为PIVT没有任何优点，却包含以上的所有缺点。你想想，PIVT方式首先要通过MMU转换成物理地址，然后才能根据物理地址index域查找cache。这在速度上没有任何优势，而且还存在歧义和别名问题。请忘记它吧。不，应该不算是忘记，因为它从来就没出现过。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>VIVT Cache问题太多，软件维护成本过高，是最难管理的高速缓存。所以现在基本只存在历史的文章中。现在我们基本看不到硬件还在使用这种方式的cache。现在使用的方式是PIPT或者VIPT。如果多路组相连高速缓存的一路的大小小于等于4KB，一般硬件采用VIPT方式，因为这样相当于PIPT，岂不美哉。当然，如果一路大小大于4KB，一般采用PIPT方式，也不排除VIPT方式，这就需要操作系统多操点心了。</p><h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><p>非一致性内存访问，就是有的内存和cpu采用高速通道相连，访问与其他cpu相连的内存时走的bus比较慢，这样访问速度就不一致。为啥不都访问一块内存，因为繁忙，用时反而高。<br>对不同内存访问速度不一致，所以就可以调整CPU将数据存在哪里，设置亲和性。不同的业务对数据的分布要求不一致，比如一个业务大家都要访问，那放在一个cpu旁的内存里就不合适。但是只有一个程序访问的时候就放在一个cpu那里好了。<br>详情<a href="https://zhuanlan.zhihu.com/p/336365600">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arm流水线</title>
    <link href="/2021/07/03/arm%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2021/07/03/arm%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>指令在处理器内部的执行过程,可以分为前端和后端,前端准备指令,后端执行指令。前端包括取指、译码、分支预测等单元,后端包括执行单元和乱序控制。  执行单元的工作就是傻呼呼的运算,而指令的乱序调度交给了乱序控制部分。<br><a href="https://cloud.tencent.com/developer/article/1150391">https://cloud.tencent.com/developer/article/1150391</a></p><h3 id="Branch-Predictor"><a href="#Branch-Predictor" class="headerlink" title="Branch Predictor"></a>Branch Predictor</h3><p>分支预测器，分支预测器猜测条件表达式的两路（也可能是其他表达式的多条）分支中哪一路最可能发生，然后推测执行这一路的指令，来避免流水线停顿造成的时间浪费。如果后来发现分支预测错误，那么流水线中推测执行的那些中间结果全部放弃，重新获取正确的分支路线上的指令开始执行，这招致了程序执行的延迟。<br>在分支预测失败时浪费的时间是从取指令到执行完指令（但还没有写回结果）的流水线的级数。现代微处理器趋向采用非常长的流水线，因此分支预测失败可能会损失10-20个时钟周期。越长的流水线就需要越好的分支预测。<br>一条条件跳转指令第一次遇到，还没有任何信息可以去预测分支。此后保持这条指令是采取还是不采取跳转的历史记录，就可以作为再遇到这条指令时猜测最可能的分支。</p><h4 id="静态预测"><a href="#静态预测" class="headerlink" title="静态预测"></a>静态预测</h4><p>确定下来猜测跳不跳，固定的判断规则。监测到循环的时候禁用分支预测、取指、解码。由LSD直通ReOrder Buffer.</p><h4 id="动态预测"><a href="#动态预测" class="headerlink" title="动态预测"></a>动态预测</h4><p>n bit动态预测，n=1的时候就沿用上次<br>n=2的时候可以分为几种状态图</p><h4 id="BTB（Branch-Target-Buffer）"><a href="#BTB（Branch-Target-Buffer）" class="headerlink" title="BTB（Branch Target Buffer）"></a>BTB（Branch Target Buffer）</h4><p>标记分支状态以及分支历史的一段内存被称为BTB，这段内存非常小，仅仅只存储了分支指令地址，以及预测的目标地址，以及预测的位。<br>当一个分支指令第一次执行时，处理器为该指令分配一个Entry放入BTB中，当指令读取请求的时候，将该指令同步放到L1的Instruction Cache以及BTB中，如果在BTB中Match上该指令，Branch Target Address将会从BTB中被读取。当指令分支执行完毕后，它的Target Address也会在BTB中被更新，Prediction Statistics也同样会更新。</p><p>取出分支历史和真的要执行的比较，看预测的对不对，进行后续操作并记录下来状态</p><h4 id="RSB-return-stack-buffer"><a href="#RSB-return-stack-buffer" class="headerlink" title="RSB(return stack buffer)"></a>RSB(return stack buffer)</h4><p>返回堆栈缓冲区(Return Stack Buffer，RSB)用来预测返回地址。RSB是一个每个处理器核的微体系结构缓冲区，它存储最近调用的N个指令的虚拟地址。当遇到ret指令时，处理器从RSB中弹出最上面的元素来预测返回流。</p><p>当RSB的布局严重偏离软件堆栈上的实际返回地址时，就会出现错误的推测。例如，在保护域上下文切换时恢复kernel/enclave/user堆栈指针时，会出现这种偏离软件堆栈上的实际返回地址情况。</p><p>此外，相同地址空间的攻击者可能会显式地覆盖软件堆栈上的返回地址，或者临时执行更新RSB的调用指令，并且不会产生体系结构层的影响。这就允许在沙箱中执行的不受信任的代码将返回控制流临时转移到沙箱环境之外的代码gadget。</p><p>RSB通常不会在物理核心之间共享，因此处理器只从在同一核心上执行的前一个分支学习。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>在以往的观念中，L1 Cache是集成在CPU中的，被称为片内Cache。在L1中还分数据Cache（D-Cache）和指令Cache（I-Cache）。它们分别用来存放数据和执行这些数据的指令，而且两个Cache可以同时被CPU访问，减少了争用Cache所造成的冲突，提高了处理器效能。以前的L2 Cache没集成在CPU中，而在主板上或与CPU集成在同一块电路板上，因此也被称为片外Cache.但从PⅢ开始，由于工艺的提高L2 Cache被集成在CPU内核中，以相同于主频的速度工作，结束了L2 Cache与CPU大差距分频的历史，使L2 Cache与L1 Cache在性能上平等，得到更高的传输速度。L2Cache只存储数据，因此不分数据Cache和指令Cache。在CPU核心不变化的情况下，增加L2 Cache的容量能使性能提升，同一核心的CPU高低端之分往往也是在L2 Cache上做手脚，可见L2 Cache的重要性。现在CPU的L1 Cache与L2 Cache惟一区别在于读取顺序。</p><p>4-Way是指四路组相连， 16Bytes/Cycle是指一个周期读取16个字节，每个line为16，64KB/16B/4=1k，所以1k个组？分组，line是一种高速缓存策略。可以查看在不在这个组，在组里后在不在这个line，然后在line里再挨个比对。<br>TLB<br>译作转译后备缓冲区，一般指的是页表缓存，48-entry就是48个。有的这个缓存还分级，数目逐渐增大，数目越少找的越快。<br>问题：地址查找是挨个查找？不是像数电中的译码器那样？</p><h3 id="Decode-queue"><a href="#Decode-queue" class="headerlink" title="Decode queue"></a>Decode queue</h3><p>分成四路译码，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。<br> Inte的处理器则采用多级译码流水线的方式来实现译码。第一级先检测出指令的起始和结束位置,第二级将指令解码为uop。一条x86 CISC指令通常对应多条uop。当一条CISC指令生成的uop数目多于4条时，就将这些CISC指令对应的uop存储在 micro-ROM(uROM)中,解码时使用査表的方式从 micro-ROM中得到,这样就简化了复杂指令的译码过程。</p><h3 id="MHSR"><a href="#MHSR" class="headerlink" title="MHSR"></a>MHSR</h3><p>MSHR是一个计算机体系结构用语，Miss-status Handling Registers 的缩写，用来记录每一项未完成的事务，记录的信息包括失效地址、关键字信息以及重命名寄存器信息。<br>一旦存储控制器返回失效访存所需要的数据，这些信息就用于重新执行。MSHR还用于合并对同一行的多个请求，防止将同一个请求发送多次。</p><h3 id="ROB"><a href="#ROB" class="headerlink" title="ROB"></a>ROB</h3><p>重排序缓存，单线程的程序是一串顺序指令。为了让多个执行部件可以同时工作，必须把串行的一串指令中，相互不相关的指令分解开，让他们可以同时在多个部件上运行。 这样一来，他们原来的先后顺序就被破坏了，所以叫做乱序执行。 为了让他们执行的结果和顺序执行时一样，增加了ROB重排序缓存，来达到乱序执行，顺序提交的目的。 超标量属于指令级并行技术，必然要采用乱序执行来增加并行度。使得每个始终周期完成的指令数大于1.<br>后端执行<br><a href="https://blog.csdn.net/whenloce/article/details/87071341?spm=1001.2014.3001.5501">https://blog.csdn.net/whenloce/article/details/87071341?spm=1001.2014.3001.5501</a></p><h3 id="Tomasulo"><a href="#Tomasulo" class="headerlink" title="Tomasulo"></a>Tomasulo</h3><p>进行动态调度时必须避免三类冒险：写后读（Read-after-Write, RAW）、写后写（Write-after-Write, WAW）、读后写（Write-after-Read, WAR）。第一种冒险也被称为真数据相关（true data dependence），而后两种冒险则并没有那么致命，它们可以由寄存器重命名来予以解决。Tomasulo算法使用了一个共享数据总线（common data bus, CDB）将已计算出的值广播给所有需要这个值作为指令源操作数的保留站。该算法尽可能降低了使用计分板技术导致的流水线停顿，从而改善了并行计算的效率.</p><p>消除WAW、WAR的原理就是一个rename的过程，通过写在RS来达到乱序还消除冒险的功能。<br>这个算法里把保留站RS去掉了，替代使用ROB。broadcast结果的步骤也直接被替代了。</p><h3 id="LSU-LSQ"><a href="#LSU-LSQ" class="headerlink" title="LSU LSQ"></a>LSU LSQ</h3><p>存储相关，回头再补。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>流水线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>流水线</tag>
      
      <tag>arm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86流水线</title>
    <link href="/2021/07/02/x86%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2021/07/02/x86%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/TaigaCon/p/7678394.html">参考文章</a><br>Intel Core Microarchitecture Pipeline<br>Intel微处理器近20年从Pentium发展到Skylake，得益于制作工艺上的巨大发展，处理器的性能得到了非常大的增强，功能模块增多，不过其指令处理pipeline的主干部分算不上有特别大的变化，更多的是为了提高指令的处理速度添加一些模块以及各模块的增强与优化。<br>本文会以Intel Core微处理器架构为例去了解Intel微处理器pipeline的各个功能模块。</p><h3 id="Core架构概览"><a href="#Core架构概览" class="headerlink" title="Core架构概览"></a>Core架构概览</h3><p>上图以指令的处理流程（pipeline）的方式对Core微处理器的架构进行了划分，指令通过各个功能模块最终实现指令的处理。需要注意的是，上图只是描画出pipeline的大致部分，本文也仅仅是对上图中的这些模块展开讨论，另外的某些模块或者细节会在以后的文章中讲述。<br>指令处理的pipeline如果按照指令的in-order/out-of-order的方式进行划分的话可以分成三部分：<br>指令的抓取以及解码是in-order的。指令流按照原本的顺序被抓取，然后送到解码器进行解码，这部分可以称为前端（Front-End）。<br>指令的执行是out-of-order的。指令在解码得到μops之后，会经过Renamer以及Reservation Station从而使μops支持out-of-order，然后经由Scheduler分发到各个Execution Unit执行。<br>指令的休止是in-order的。指令执行完成后，在Re-Order Buffer内对执行结果重新排序，使得执行结果顺序输出。</p><h3 id="Front-End"><a href="#Front-End" class="headerlink" title="Front End"></a>Front End</h3><h4 id="Instruction-Fetch-Unit"><a href="#Instruction-Fetch-Unit" class="headerlink" title="Instruction Fetch Unit"></a>Instruction Fetch Unit</h4><p>指令获取单元包含以下部件：instruction translation lookaside buffer（ITLB），instruction prefetcher，instruction cache，predecode unit。<br>其中ITLB用于存放虚拟地址向物理地址的转换表，目的是免去每次从内存查看页表的操作；instruction prefecher用于抓取接下来可能会执行的指令，instruction cache用于存储接下来要执行的指令；predecode unit用于指令的初步解码。</p><h4 id="Instruction-Cache-and-ITLB"><a href="#Instruction-Cache-and-ITLB" class="headerlink" title="Instruction Cache and ITLB"></a>Instruction Cache and ITLB</h4><p>指令是以16字节对齐的方式取进CPU的，在读取指令时，会通过ITLB得到正确的物理地址，从内存中把指令读取到instruction cache以及instruction prefetch buffer。一旦将要执行的指令在cache中，则会把该16字节的指令发送到predecoder。一般来说，程序的指令平均长度为4字节，也就是说平均每一次可以抓取4条指令。<br>如果一段目标代码的开头不是16字节对齐的，则会导致fetch效率的下降</p><p>如果接下来的指令为跳转分支，则可能会造成解码效率的下降</p><p>在一般的代码中，约每10条指令会出现一个分支，也就是说平均每3~4个时钟周期就会出现一次上述的情况。<br>不过，通常前端不会成为指令处理的瓶颈，因为pipeline的其他某些部分的效率无法达到每个时钟周期处理4条指令的程度，除非程序中有大量throughput非常高的指令，并且这些指令之间能很好地搭配出几条依赖链（如采用SSE2的音视频处理内核）。</p><h4 id="Instruction-PreDecode"><a href="#Instruction-PreDecode" class="headerlink" title="Instruction PreDecode"></a>Instruction PreDecode</h4><p>指令预解码单元会接收到从instruction cache或者instruction prefetch buffer发出的16字节，并执行以下任务：<br>解码出指令的长度<br>解码出指令的所有前缀<br>为指令打上标记（如“是分支 / is branch”）<br>预解码单元每个时钟周期可以向instruction queue写入6条指令。预解码的后面获取的指令只能等待前面获取的指令解码完毕后才能开始解码。例如，某一次获取的16字节中含有7条指令，那么预解码单元会在第一个时钟周期写入6条指令，第二个时钟周期写入1条指令，而后续获取的指令会在第三个时钟周期进行解码，如此一来，前两个时钟周期平均解码的指令为3.5条。<br>另外，有两个前缀会导致解码变慢。这两个前缀会动态地改变指令的长度，被称为length changing prefixes（LCPs）。<br>66H Operand-Size Prefix 这个前缀会改变操作数的长度。比如在32位处理器中，默认操作数长度为32位，也就是说所用到的寄存器为EAX、EBX等（mov eax, 0xef）。如果使用了AX、BX等寄存器（mov ax, 0xef），此时操作数长度为16位，则会在指令前面添加前缀66H。<br>67H Address-Size Prefix 这个前缀会改变地址的位数。比如在32位处理器中，默认的地址为32位（mov eax, [edx]），如果某条指令希望用16位进行寻址的话（mov eax, [dx]），则会在指令前面添加前缀67H。<br>这两个前缀在IA-32系列之前的处理器上会导致predecode的延迟，不过在新系列的处理器上只有特定情况才会有副作用，比如说工作在保护模式的处理器，具体情况请自行查看资料。</p><h4 id="Instruction-Queue"><a href="#Instruction-Queue" class="headerlink" title="Instruction Queue"></a>Instruction Queue</h4><p>Instruction Queue位于predecode unit与decoder之间，他最多可以存储18条指令，并且每个时钟周期可以向decoder发送5条指令，5条指令中只能包含1条macro-fusion指令。<br>Instruction Queue（IQ）最大的作用就是侦测并存储循环指令。IQ内提供了能存储小于18条指令的loop cache，如果loop stream detector（LSD）侦测到IQ内的指令为循环内的指令，则会把这些指令锁定下来，那么在循环期间就可以直接从IQ中获取指令到解码器，从而省去前面fetch以及predecode等工作。如此一来能很好地提高效率以及降低功耗。<br>总结来说LSD可以提供以下便利：<br>不会因为循环的跳转而影响效率。<br>不会因为循环的第一条指令不对齐而影响效率。<br>降低前端的功耗，因为在循环期间instruction cache，predecode unit等可以处于空闲状态。<br>不过如果想很好地利用这个功能的话就需要把循环内指令的大小控制在一定范围内。<br>※后续的处理器在decoder与execution unit之间添加了Instruction Decoder Queue，LSD也移动到了这个位置。</p><h4 id="Instruction-Decode"><a href="#Instruction-Decode" class="headerlink" title="Instruction Decode"></a>Instruction Decode</h4><p>Core微处理器中包含了四个指令解码器。其中第一个解码器Decoder 0的功能最强，可以解码最高为4 μops的指令，其余的三个解码器只能解码单μop的指令。<br>尽管解码器存在上述分工，不过得益于某些改进策略（micro-fusion，macro-fusion，Stack Pointer Tracker），因此很多在execution unit时会被拆分成多个μops分别执行的指令在decoder阶段都会被当成单一的μop，如此一来那三个只能解码单μop的解码器就可以执行更多的解码任务，指令也没必要按照4-1-1-1的方式进行配置了。</p><h4 id="Micro-code-sequencer-ROM-MSROM"><a href="#Micro-code-sequencer-ROM-MSROM" class="headerlink" title="Micro-code sequencer ROM (MSROM)"></a>Micro-code sequencer ROM (MSROM)</h4><p>MSROM用于存储复杂指令的μops。对于那些大于4μops或者相当复杂（不常用）的指令，是无法通过decoder进行解码的，此时decoder会请求MSROM的协助，MSROM收到请求后会传输与指令对应的μops到Decode Pipeline/Decoded ICache上。<br>使用MSROM指令会导致解码时间出现较大的增加，因此应尽量避免使用MSROM指令。比如，对于PUSH与CALL指令来说，如果操作数为内存，则该指令的解码需要寻求MSROM的协助，但是如果操作数为寄存器，则可以由decoder直接解码。因此应当先把数据从内存mov进寄存器，再执行PUSH或CALL的操作。<br>Instruction from MSROM    Recommendation Replacement Instructions<br>CALL m16/m32/m64    Load + CALL reg<br>PUSH m16/m32/m64    Store + RSP update<br>(I)MUL r/m16 (Result DX:AX)    Use (I)MUL r16, r/m16 extended precision not required, or (I)MUL r32, r/m32<br>(I)MUL r/m32 (Result EDX:EAX)    Use (I)MUL r32/m32 if extended precision not required, or (I)MUL r64, r/m64<br>(I)MUL r/m64 (Result RDX:RAX)    Use (I)MUL r64, r/m64 if extended precision not required<br>其他如DIV，CPUID，AESDEC等指令也是MSROM指令，MSROM指令一般都会有较高的latency以及1/throughput，具体哪条指令为MSROM指令以及相关数据还请查看Intel 64 and IA-32 Architectures Optimization Reference Manual。</p><h3 id="The-Out-of-Order-Engine"><a href="#The-Out-of-Order-Engine" class="headerlink" title="The Out-of-Order Engine"></a>The Out-of-Order Engine</h3><p>散序引擎（Out-of-Order Engine）能大大提高指令的执行效率。散序引擎通过侦测各指令间的依赖关系，使得指令形成各不相干的依赖链，那么某条依赖链上的指令就能在其它依赖链等待资源时进入execution unit执行，实现了对处理器的充分利用。正是这种基于资源的处理方式使得指令打破了其原本的处理顺序，故称为Out-of-Order。散序引擎包含三个主要部分。</p><h4 id="Renamer-Allocator"><a href="#Renamer-Allocator" class="headerlink" title="Renamer/Allocator"></a>Renamer/Allocator</h4><p>指令在前端经过解码后会得到μops队列，Renamer/Allocator对队列中的μop执行以下操作：<br>把μops相关的逻辑寄存器重命名为物理寄存器，用Register alias table(RAT)维护逻辑寄存器与物理寄存器之间的映射关系。<br>为μops开辟资源，如load或store所需的临时buffer。<br>把μops与合适的端口进行绑定。<br>其中寄存器重命名与Out-of-Order尤为相关。如果发现μops对整个寄存器的写入操作，Renamer会为逻辑寄存器映射到新的物理寄存器，如此一来就切断了依赖链，为Out-of-Order execution打下了基础。</p><h4 id="Scheduler-Reservations-station"><a href="#Scheduler-Reservations-station" class="headerlink" title="Scheduler (Reservations station)"></a>Scheduler (Reservations station)</h4><p>Scheduler（RS）的目的是把μops分配到相应的execution port。为了实现这个目的，RS必须具备识别μop是否ready的能力。当μop的所有的源（source）都就位时则表明该μop为ready，可以让RS调度到execution unit执行。RS会根据Issue Port的可用情况以及已就绪μops的优先级来对μop进行调度。<br>RS会为每个进入其中的μop开辟一项，用于存储正在等待资源的μop，Core微处理器中的RS可以容纳32项μops。<br>在scheduler之前的μops的顺序都是in-order的，经过scheduler之后μops变为了out-of-order。</p><h4 id="Retirement-Reorder-buffer"><a href="#Retirement-Reorder-buffer" class="headerlink" title="Retirement (Reorder buffer)"></a>Retirement (Reorder buffer)</h4><p>Reorder buffer（ROB）主要用于记录μops的状态以及存储EU执行完成后返回的结果，然后按照in-order的顺序把执行结果写回寄存器，使得在用户层看来指令在以in-order的顺序执行，in-order写回的这一步被称为retirement。Core微处理器一共可以容纳96项μops。</p><p>Out-of-Order Engine在Sandy Bridge微处理器后进行了大幅度的改变，相关细节请查看Re-Order Buffer。</p><h3 id="Execution-Units"><a href="#Execution-Units" class="headerlink" title="Execution Units"></a>Execution Units</h3><p>在RS的指令就绪后，RS会通过issue port（IP）把指令调度到相应的EU执行，Core微处理器一共有6个IP，也就是说一次性最多可以发出6个μops。在执行完成指令后，除了少数指令之外（如store），一般都需要把执行结果写回寄存器（或者说ROB），经由writeback port（WP）进行写回，Core微处理器一共有4个WP。<br>下面的表为Core微处理器（06-0FH）以及Enhanced Core微处理器（06-17H）的port及其目的端的EU的功能以及Latency、Throughout。<br>Executable Operation    Latency, Throughput    Comment1<br>Signature=06_0FH    Signature=06_17H<br>Interger ALU<br>Interger SIMD ALU<br>FP/SIMD/SSE2 Move and Logic    1, 1<br>1, 1<br>1, 1    1, 1<br>1, 1<br>1, 1    Includes 64-bit mode integer MUL; Issue port 0; Writeback Port 0;<br>Single-precision(SP) FP MUL<br>Double-precision FP MUL    4, 1<br>5, 1    4, 1<br>5, 1    Issue port 0;Writeback port 0<br>FP MUL (x87)<br>FP Shuffle<br>DIV/SQRT    5, 2<br>1, 1<br>-, -8    5, 2<br>1, 1<br>-, -8    Issue port 0;Writeback port 0<br>FP shuffle does not handle QW shuffle<br>Integer ALU<br>Integer SIMD ALU<br>FP/SIMD/SSE2 Move and Logic    1, 1<br>1, 1<br>1, 1    1, 1<br>1, 1<br>1, 1    Excludes 64-bit mode integer MUL;<br>Issue port 1;Writeback port 1;<br>FP ADD<br>QW Shuffle    3, 1<br>1, 12    3, 1<br>1, 13    Issue port 1; Writeback port 1;<br>Integer loads<br>FP loads    3, 1<br>4, 1    3, 1<br>4, 1    Issue port 2; Writeback port 2;<br>Store address4    3, 1    3, 1    Issue port 3;<br>Store data5            Issue port 4;<br>Integer ALU<br>Integer SIMD ALU<br>FP/SIMD/SSE2 Move and Logic    1, 1<br>1, 1<br>1, 1    1, 1<br>1, 1<br>1, 1    Issue port 5; Writeback port 5<br>QW shuffles<br>128-bit Shuffle/Pack/Unpack    1, 122-4, 2-46    1, 131-3, 17    Issue port 5; Writeback port 5</p><h5 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h5><p>如果向同一个port调度不同latency的操作，有可能会导致writeback bus冲突，因而影响性能。例如向port 1：clock 0发出的操作的latency为2，clock 1发出的操作的latency为1，那么在clock 2时两者都需要writeback port 1进行写回，此时必然会导致其中的一个操作延迟写回。<br>当Core执行128-bit shuffle操作时会有较长的latency并降低throughput。<br>Enhanced Core独立出来了128-bit shuffle操作，在port 5，并且提升了执行速度。<br>为store的写回做准备，相关的地址操作。<br>为store的写回做准备，相关的数据操作，数据写回内存与cache、memory相关，其中涉及到一些处理逻辑，后面分析。<br>Core中的128-bit Shuffle/Pack/Unpack等操作用的都是QW shuffle单元。<br>Enhanced Core中128-bit Shuffle/Pack/Unpack等操作有独立的128-bit单元。<br>DIV/SQRT等操作的latency与throughput是数据相关的。通俗地说就是，简单的DIV/SQRT的latency会较短，复杂的DIV/SQRT的latency则较长。</p><h3 id="Advanced-Memory-Access"><a href="#Advanced-Memory-Access" class="headerlink" title="Advanced Memory Access"></a>Advanced Memory Access</h3><p>Intel处理器一般都含有多级data cache。Core微处理器就含有两级data cache，其中每个核心内部的为L1 data cache、两个核心共用外部的L2 cache。<br>一个核心内部包含的数据访问相关部分有：<br>L1 data cache，也被称为data cache unit（DCU），它可以同时处理多个cache misses以及stores/loads；能维护cache coherency（cache一致性）。cache line为64-byte。<br>Data translation lookaside buffer（DTLB），即缓存在核心内的虚拟物理地址转换表。Core的实现分为分两层：DTLB0、DTLB1。DTBL0用于loads，DTLB1用于stores以及作为DTBL0的loads misses候补。<br>Page miss handler（PMH），当所请求虚拟地址转换的页表不在TLB时，会由PMH进行处理。<br>Memory ordering buffer（MOB），由load buffer与store buffer组成，用于支持loads与stores的out of order处理、预测（speculative）处理。</p><p>Load Buffer and Store Buffer<br>Core微处理器的load unit以及store unit一个时钟周期可以从DCU中读取或者写入最多128-bit。DCU以及EU之间有load buffer与store buffer，用于暂存load与store指令访问的数据。<br>load指令在Allocator期间，会被分配一个load buffer，在load EU执行期间把数据从DCU读入load buffer，然后通过writeback port把数据写回ROB，在retirement时会把数据从ROB写入register。<br>store指令在Allocator期间，会被分配一个store buffer，在store EU执行期间把目标内存地址以及数据写入store buffer，在retirement后会把数据写入DCU。</p><p>内存数据的存储相比其它普通的指令来说，运行时间受到更多因素的影响，如cache miss、总线忙、数据不对齐等，而加入load buffer以及store buffer能有效降低读写内存时受到的负面影响，把数据留在离EU更近的地方，使得对内存数据的处理显得更为本地化，即对EU来说，所要处理的数据都更容易获取，割离前后端（读写内存）的影响（in-flight）。</p><h4 id="Out-of-Order"><a href="#Out-of-Order" class="headerlink" title="Out of Order"></a>Out of Order</h4><p>微处理器中相关的内存读写操作是out of order的，不过out of order的内存操作需要遵循以下规则：<br>对于老的微处理器来说（如P6），在一个store的地址没搞清楚之前，它后面的loads都不能提到该store之前，等到地址确定后才能做出抉择。不过新系列的处理器可以通过预测来决定load是否可以提前，请参考下面的Memory Disambiguation。<br>如果访问的是同一个地址，load不能提到位于它前面的store之前。<br>对于老的微处理器来说（如P6），stores之间的顺序不能调换，比较新的微处理器似乎可以？<br>如下图所示：</p><h4 id="Speculative-Execution"><a href="#Speculative-Execution" class="headerlink" title="Speculative Execution"></a>Speculative Execution</h4><p>由于指令的执行分为fetch、decode、execution、retirement等多个阶段，不同的微处理器细分开来可以有十多到二十多级的pipeline。执行到分支（Branch）的时候，按理来说是需要等条件的最终执行结果出来才能知道接下来走那个分支，不过如此一来，在等待执行结果的途中pipeline中的各部分器件会处于空闲状态，导致资源浪费以及指令执行效率不高。<br>解决方法就是微处理器会预测接下来会走哪个分支，微处理器把该分支的指令获取并处理。不过由于该分支只是预测分支，实际并不一定会走该分支，因此分支内的指令不应该执行retirement步骤，直到确定了会走该分支。如果实际上不走预测分支，则需要把预测分支清空，重新执行另一分支。<br>Load的retirement是把数据从ROB写入register，而Store的retirement是把数据从store buffer写入DCU。预测分支内的Load与Store就不会执行这些步骤，直到确定会走该预测分支。</p><h4 id="Memory-Disambiguation"><a href="#Memory-Disambiguation" class="headerlink" title="Memory Disambiguation"></a>Memory Disambiguation</h4><p>前面在讨论Out of Order的内存访问时，说到在老的微处理器中，如果指令Store的地址未知时，位于其后的Load指令必须等到计算出该Store的地址后才能判断Load是否能提前，不过新的处理器采用了Memory Disambiguation（MD）技术，使得可以在不知道Store地址的情况下决定是否提前执行Load。<br>我们先来看看Load提前会得到怎么样的好处</p><p>在采用Memory Disambiguation前，上面的指令需要9个时钟周期才能完成，而采用了该技术之后仅需5个时钟周期即可完成，Load提前执行使得位于其后的指令也能提前执行，进而充分利用了各个不同功能的EU。据统计，在一般的工作站中，Load占全部指令的10<del>25%，Store占比30</del>45%，可以想象采用MD技术后，指令的执行效率会有相当的提升。<br>那么在MD中，Load提前到一个未知地址的Store之前执行的以依据是什么？微处理器主要根据过去执行指令来进行预测，准确率达到90%以上。不过由于是预测，因此不一定准确，也就如上述speculate的讨论一样不能执行retirement步骤，直到算出Store的地址。</p><h4 id="Store-Forwarding"><a href="#Store-Forwarding" class="headerlink" title="Store Forwarding"></a>Store Forwarding</h4><p>如果在一个store后紧跟着对同一地址的load，那么load就能直接从store中获取所需的数据，而不用再次去到内存中获取，这种技术被称为Store Forwarding（ST）。ST需要满足以下几个条件：<br>store必须为相同地址的load之前的最后一个store。<br>store所存储的数据必须等于或大于load所读取的数据。<br>load的数据不能超越cache line边界（Core之后的微处理器去除了这个限制）。<br>load的数据不能超越8字节的边界（Core之后的微处理器去除了这个限制），除非是16字节的读取。<br>load的地址必须跟store的地址一样（Nehalem之后的微处理器去除了这个限制），除非是以下的情况：<br>64 bit的store可以forward它任意一半32 bit。<br>128 bit的store可以foward它任意一半的64 bit。<br>128 bit的store可以foward它任意四分之一的32 bit。</p><p>总体来说，随着微处理器的更新，限制越来越少，不过具体还请查看相关资料。</p><h4 id="Data-Prefetch-to-L1-caches"><a href="#Data-Prefetch-to-L1-caches" class="headerlink" title="Data Prefetch to L1 caches"></a>Data Prefetch to L1 caches</h4><p>Core微处理器提供了两个预取数据的硬件(hardware prefetcher)，用于预先获取数据进L1 data cache (DCU)：<br>Data cache unit (DCU) prefetcher - 也就是常说的流预取器（stream prefetcher），一旦发现当前获取的某个数据的地址是不久前获取的某个数据地址的递增，就会触发该prefetcher，处理器会认为我们在访问一段连续的数据，因此会自动把其递增地址上的下一个cache line获取进入cache。</p><p>Instruction pointer (IP)-based strided prefetcher - 该prefetcher会跟踪load指令，如果发现load指令的地址之间存在相同的间隔，那么该prefetcher就会被触发，去预取下一个间隔所在的地址的数据。这种预取可以是前向也可以是后向的，并且间隔的大小最大可以到达2KB。</p><p>数据的预取还需要满足以下几个条件：<br>load的数据是从writeback类型的内存（内存访问的一种cache类型，writeback简单地说就是load与store都要经过cache）中获取的。<br>要预取的数据在一页（page boundary of 4KB）之内。<br>pipeline在处理过程中不会进行限制与锁定。<br>在load的过程中没有太多的cache miss。<br>总线不是太忙。<br>没有连续的流写回操作（continuous stream of stores）。</p><h4 id="Data-Prefetch-to-L2-caches"><a href="#Data-Prefetch-to-L2-caches" class="headerlink" title="Data Prefetch to L2 caches"></a>Data Prefetch to L2 caches</h4><p>L2 cache上的数据预取由Data prefetch logic（DPL）进行管理。L2要从内存预获取什么数据，依据的是DCU过去从L2访问过什么数据。DPL维护了两个独立的队列，用于存储DCU访问的数据的地址：一条队列是用于存储upstreams，即递增的地址，有12项；另一条队列用于存储downstreams，即递减的地址，有4项。每一项用于跟踪一页（4KB）的地址访问情况。<br>DPL会监控DCU对于连续递增序列（incremental sequences，known as streams）的读取情况。一旦DPL侦测到DCU在访问的数据是流，则会预读取下一条cache line。如DCU向L2要求访问cache line A以及A+1，那么DPL会认为DCU接下来需要访问A+2，那么就会去预取cache line A+2，如果DCU访问了A+2，那么DPL就会预取A+3。递减序列同理。<br>上面描述的是DPL的基础功能。DPL在Pentium M微处理器首次引入，在Core微处理器时已经有相当强大的功能，如：能判断何时跳过某些不需要的cache lines；每次处理两个预读；预取的cache line可以比load的数据领先8个cache line；可以根据总线的繁忙程度动态调整等。</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>流水线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>流水线</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流水线基础</title>
    <link href="/2021/07/01/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/07/01/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="处理器性能共公式"><a href="#处理器性能共公式" class="headerlink" title="处理器性能共公式"></a>处理器性能共公式</h3><p>性能=程序/时间=程序/指令 * 指令/周期数 * 周期/时间<br>第一部分是指令数量（指令集、编译器、操作系统），第二部分每条指令的周期数也叫CPI（指令集），第三条每个周期的时间（硬件时间的复杂性、cpu频率）</p><p>减少时钟周期-流水线技术<br>深度流水线使得每个流水段延时（时钟周期）减少。感觉这里的时钟周期不是真的时钟周期，只是流水线达到的效果<br>但是一旦分支预测出错，将会开销更大。<br>基本操作不应需要太多周期，比如ALU单元<br>cpi目标是达到1甚至小于1，其倒数ipc大于1，现在超流水线性能很强，用大于1的IPC方便</p><h3 id="标量超标量"><a href="#标量超标量" class="headerlink" title="标量超标量"></a>标量超标量</h3><p>标量处理器：每个时钟周期最多取出一条指令发射。<br>超标量：多条<br>并行处理器性能<br>为了在超标量设计中获得很高的ipc，流水线需要很宽<br>流水线深可以提高频率。<br>不能又宽又深</p><p>标量一个处理器执行计算<br>向量：多个</p><p>当N很大时，E接近1-h。继续提升N会造成属于向量计算时间趋近于0（向量内容很快完成），所以标量时间就影响很大。</p><p>标量部分并非必须顺序执行，并行一点处理也有很大提升。<br>指令级并行ILP,并行度极限典型的小于2，后来理论上可以比较大，但是实际上只是有一定提升</p><h3 id="超标量与超流水"><a href="#超标量与超流水" class="headerlink" title="超标量与超流水"></a>超标量与超流水</h3><p>超流水线相对于基准标量流水线具有更高的流水度。IL（发射延迟）更小了。发射速度比执行速度还快。MP=m<em>k 超流水应该是将一个动作拆分为m个执行小步骤。<br>超标量是能够同时发射多条指令，宽度n更大。MP(能够执行的最大指令数)等于n</em>k.<br>m=n时，二者效果一致<br>可以两者同时用，m<em>n</em>k<br>高时钟速度下存储器延迟比CPU慢三个数量级以上，需要想办法扩展存储器带宽。挑战由数据操作变为数据移动<br>流水线处理器</p><p>流水化将系统分为很多段，每个段之间加缓冲，缓冲的作用应该是为了防止时钟紊乱。流水线不呢无限制加，一个原因是深了寄存器数量多，价格高<br>价格性能比模型曲线是个对勾函数，有最低点。左右分别是“不够完全流水化”“过度流水化”<br>流水线理想假设<br>一致的运算分量 每个阶段的延迟不一定一致，但是我们按照最长的等待会造成内部碎片<br>重复的运算 多功能流水线会造成一部分数据不需要全部的流水段，造成外部碎片<br>独立的运算 有的时候会流水线停顿，一个结果能带另一个结果的出现，被迫停顿会造成外部碎片的效果<br>指令流水线<br>为了减少内部碎片，可以把几个步骤中时间较短的合成一个子运算，尽量一致。<br>指令流水线天然多功能，应该支持所有指令运算同时减少无效、空闲的机器周期<br>指令流水线一般相关，会造成停顿，应该尽量减少流水线停顿<br>指令集对这三条也有对应的影响<br>均衡流水线的方法：延迟多的拆成多个分量，少的多个合一起。</p><p>arm指令变长？<br>32位定长，MIPS也是32位定长<br>与86对比流程图</p><h3 id="MS-ROM"><a href="#MS-ROM" class="headerlink" title="MS ROM"></a>MS ROM</h3><p>在X86指令中，有一些连复杂解码器都认为复杂的指令。这些指令会被翻译成超过4条uops，它们是从microcode sequencer(MS) ROM 绕道译码的。此时，MSROM每周期会发射超过4条指令，直到microcode sequencer完成了工作。在此期间，译码器停止工作。对于更复杂的指令译码可能会产生问题，可以通过微代码修改译码规则，并没有焊死。</p><h3 id="Stack-Engine"><a href="#Stack-Engine" class="headerlink" title="Stack Engine"></a>Stack Engine</h3><p>x86有这一个专门的stack machine 操作。像push，pop和call，ret这样的指令，是工作在stack pointer（ESP）上的。<br>像push这样的指令翻译成store指令和将ESP-4的指令。此时的减法操作将会被Stack Engine完成。Stack Engine位于decoders的后面，监视uOps指令流。Stack Engine 将会抓住输入的更新栈寄存器的操作。这可以更新栈指针的uops造成的流水线的负担。换句话说，这相对于将这些操作放入流水线并通过执行单元计算，更加简单更加快速。</p><h3 id="DSB"><a href="#DSB" class="headerlink" title="DSB"></a>DSB</h3><p>这里这个<a href="https://blog.csdn.net/hit_shaoqi/article/details/106751490">uop</a> 和<a href="https://blog.csdn.net/Hipercomer/article/details/38390375">trace cache</a>比较像，比较两个链接可以发现都是一个缓存微指令的地方，省的分支预测错误导致的再一次指令译码。</p><h3 id="ROB"><a href="#ROB" class="headerlink" title="ROB"></a>ROB</h3><p>里面的Retirement与ARM的commit很像<br>Scheduler<br>像是dispatch、issue的结合体。<br>整体结构还可以参考<a href="https://www.cnblogs.com/TaigaCon/p/7678394.html">这篇文章</a></p><h3 id="分支预测差别"><a href="#分支预测差别" class="headerlink" title="分支预测差别"></a>分支预测差别</h3><p>ARM的处理器有个特点，就是乱序执行能力不如X86。换句话说，就是用户在使用电脑的时候，他的操作是随机的，无法预测的，造成了指令也无法预测。X86为了增强对这种情况下的处理能力，加强了乱序指令的执行。此外，X86还增强了单核的多线程能力。这样做的缺点就是，无法很有效的关闭和恢复处理器子模块，因为一旦关闭，恢复起来就很慢，从而造成低性能。为了保持高性能，就不得不让大部分的模块都保持开启，并且时钟也保持切换。这样做的直接后果就是耗电高。而ARM的指令强在确定次序的执行，并且依靠多核而不是单核多线程来执行。这样容易保持子模块和时钟信号的关闭，显然就更省电。</p><p>N1架构 ARM官网 V apple<br>分支预测细节<br>csapp实验题</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
      <category>流水线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>流水线</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
